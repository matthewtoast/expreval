{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["import * as seedrandom from 'seedrandom';\nimport { z } from 'zod';\n\nexport type DictOf<T> = { [key: string]: T };\n\nexport const ZExprScalar = z.union([\n  z.number(),\n  z.string(),\n  z.boolean(),\n  z.null(),\n]);\nexport type TExprScalar = number | string | boolean | null;\nexport type TExprArray = TExprValue[];\nexport type TExprObject = { [key: string]: TExprValue };\nexport type TExprValue = TExprScalar | TExprObject | TExprArray;\n\nexport type TExprFuncSync = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExprValue[]\n) => TExprValue;\nexport type TExprFuncLazy = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExpression[]\n) => TExprValue;\nexport type TExprFuncDef =\n  | {\n      assignment?: true;\n      lazy?: undefined;\n      f: TExprFuncSync;\n    }\n  | {\n      lazy: true;\n      f: TExprFuncLazy;\n    };\n\nexport type TBinopDef = {\n  alias: string;\n};\nexport type TUnopDef = {\n  alias: string;\n};\n\nexport type TExprResult = {\n  result: TExprValue;\n  ctx: TExprContext;\n};\n\nexport type TExprContext = {\n  rng: () => number;\n  funcs: DictOf<TExprFuncDef>;\n  binops: DictOf<TBinopDef>;\n  unops: DictOf<TUnopDef>;\n  get: (scope: TScope, key: string) => TExprValue;\n  set: (scope: TScope, key: string, value: TExprValue) => void;\n  call?:\n    | ((\n        ctx: TExprContext,\n        scope: TScope,\n        method: string,\n        args: TExprValue[],\n      ) => TExprValue)\n    | undefined;\n  lazy?:\n    | ((\n        ctx: TExprContext,\n        scope: TScope,\n        method: string,\n        args: TExpression[],\n      ) => TExprValue)\n    | undefined;\n};\n\nexport type TScope = { [key: string]: TExprValue };\n\nexport type TExpression =\n  | TCallExpression\n  | TIdentifierExpression\n  | TBinaryExpression\n  | TLiteralExpression\n  | TConditionalExpression\n  | TUnaryExpression\n  | TTemplateLiteralExpression\n  | TArrayLiteralExpression\n  | TObjectLiteralExpression\n  | TComputedPropertyExpression\n  | TArrowFunctionExpression;\n\nexport type TTemplateLiteralPart =\n  | ['chunks', string]\n  | ['expression', TExpression];\n\nexport type TTemplateLiteralExpression = {\n  type: 'TemplateLiteral';\n  parts: TTemplateLiteralPart[];\n};\n\nexport type TComputedPropertyExpression = {\n  type: 'ComputedProperty';\n  expression: TExpression;\n};\n\nexport type TArrayLiteralExpression = {\n  type: 'ArrayLiteral';\n  elements: TExpression[];\n};\n\nexport type TObjectLiteralExpression = {\n  type: 'ObjectLiteral';\n  properties: {\n    name: TExpression;\n    value: TExpression | undefined;\n  }[];\n};\n\nexport type TCallExpression = {\n  type: 'CallExpression';\n  callee: TIdentifierExpression;\n  arguments: TExpression[];\n};\n\nexport type TIdentifierExpression = {\n  type: 'Identifier';\n  name: string;\n};\n\nexport type TBinaryExpression = {\n  type: 'BinaryExpression';\n  left: TExpression;\n  operator: string;\n  right: TExpression;\n};\n\nexport type TLiteralExpression = {\n  type: 'Literal';\n  value: string;\n  raw: string;\n};\n\nexport type TConditionalExpression = {\n  type: 'ConditionalExpression';\n  test: TExpression;\n  consequent: TExpression;\n  alternate: TExpression;\n};\n\nexport type TUnaryExpression = {\n  type: 'UnaryExpression';\n  argument: TExpression;\n  operator: string;\n};\n\nexport type TArrowFunctionExpression = {\n  type: 'ArrowFunction';\n  parameters: { type: 'BoundName'; name: string }[];\n  result: TExpression;\n};\n\nexport const CONSTS: DictOf<TExprValue> = {\n  E: Math.E,\n  LN10: Math.LN10,\n  LN2: Math.LN2,\n  LOG10E: Math.LOG10E,\n  LOG2E: Math.LOG2E,\n  PI: Math.PI,\n  SQRT1_2: Math.SQRT1_2,\n  SQRT2: Math.SQRT2,\n};\n\nconst BINOP_MAP = {\n  '**': { alias: 'pow' },\n  '*': { alias: 'mul' },\n  '/': { alias: 'div' },\n  '%': { alias: 'mod' },\n  '+': { alias: 'add' },\n  '-': { alias: 'sub' },\n  '>>>': { alias: 'bitwiseRightShiftUnsigned' },\n  '<<': { alias: 'bitwiseLeftShift' },\n  '>>': { alias: 'bitwiseRightShift' },\n  '<=': { alias: 'lte' },\n  '>=': { alias: 'gte' },\n  '<': { alias: 'lt' },\n  '>': { alias: 'gt' },\n  '===': { alias: 'eq' },\n  '!==': { alias: 'neq' },\n  '==': { alias: 'eq' },\n  '!=': { alias: 'neq' },\n  '&': { alias: 'bitwiseAnd' },\n  '^': { alias: 'bitwiseXor' },\n  '|': { alias: 'bitwiseOr' },\n  '&&': { alias: 'and' },\n  '||': { alias: 'or' },\n  ':=': { alias: 'setVar' },\n  '+=': { alias: 'setAdd' },\n  '-=': { alias: 'setSub' },\n  '/=': { alias: 'setDiv' },\n  '*=': { alias: 'setMul' },\n  '??': { alias: 'nullCoalesce' },\n};\n\nconst UNOP_MAP = {\n  '+': { alias: 'number' },\n  '-': { alias: 'negate' },\n  '~': { alias: 'bitwiseNot' },\n  '!': { alias: 'not' },\n};\n\nconst IgnoreWhitespace = (Rule) => Ignore(/^\\s+/, Rule);\nconst QuoteToken = Any(\n  /^('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')/,\n  /^(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")/,\n);\nconst NumericToken = Any(\n  /^((?:[0-9]+\\.?[0-9]*|\\.[0-9]+)(?:[eE][-+]?[0-9]+)?)\\b/,\n  /^(0[xX][0-9a-fA-F]+)\\b/,\n);\nconst NullToken = /^(null)\\b/;\nconst BooleanToken = /^(true|false)\\b/;\nconst IdentifierToken = /^([a-zA-Z_$][a-zA-Z0-9_$.]*)/;\nconst InterpolationChunkToken = /^((?:\\$(?!{)|\\\\.|[^`$\\\\])+)/;\nconst BinaryOperatorPrecedence = [\n  '**',\n  Any('*', '/', '%'),\n  Any('+', '-'),\n  Any('>>>', '<<', '>>'),\n  Any('<=', '>=', '<', '>'),\n  Any('===', '!==', '==', '!='),\n  /^&(?!&)/,\n  '^',\n  /^\\|(?!\\|)/,\n  '&&',\n  '||',\n  '??',\n  Any(':=', '+=', '-=', '*=', '/='),\n];\n\nconst INVALID_IDENT_REGEX = /^__proto__|prototype|constructor$/;\n\nexport function createExprContext({\n  funcs,\n  binops,\n  unops,\n  seed = 'expreval',\n  get,\n  set,\n  call,\n}: Partial<TExprContext> & { seed?: string }): TExprContext {\n  const vars: { [key: string]: TExprValue } = {};\n  return {\n    rng: seedrandom.default(seed),\n    funcs: { ...STDLIB, ...funcs },\n    binops: { ...BINOP_MAP, ...binops },\n    unops: { ...UNOP_MAP, ...unops },\n    get: (scope, name) => {\n      if (name.match(INVALID_IDENT_REGEX)) {\n        return 0;\n      }\n      if (get) {\n        return get(scope, name) ?? null;\n      }\n      return vars[name] ?? null;\n    },\n    set: (scope, name, value) => {\n      if (name.match(INVALID_IDENT_REGEX)) {\n        return;\n      }\n      if (set) {\n        return set(scope, name, value);\n      }\n      vars[name] = value;\n      return;\n    },\n    call,\n  };\n}\n\nexport function evaluateExpr(\n  code: string,\n  ctx: TExprContext = createExprContext({}),\n  scope: TScope = {},\n): TExprResult {\n  return {\n    result: executeAst(parseExpr(code), ctx, scope),\n    ctx,\n  };\n}\n\nexport default evaluateExpr;\n\nexport function parseExpr(code: string): TExpression {\n  const parser = Parser(DefaultGrammar);\n  return parser(code.replace(/\\/\\/.*\\n/g, ''));\n}\n\nexport function remapAst(\n  ast: TExpression,\n  res: (ast: TExpression) => TExpression,\n): TExpression {\n  switch (ast.type) {\n    case 'Literal':\n      return res(ast);\n    case 'Identifier':\n      return res(ast);\n    case 'CallExpression':\n      ast.arguments = ast.arguments.map((el) => remapAst(el, res));\n      return res(ast);\n    case 'BinaryExpression':\n      ast.left = remapAst(ast.left, res);\n      ast.right = remapAst(ast.right, res);\n      return res(ast);\n    case 'ConditionalExpression':\n      ast.test = remapAst(ast.test, res);\n      ast.consequent = remapAst(ast.consequent, res);\n      ast.alternate = remapAst(ast.alternate, res);\n      return res(ast);\n    case 'UnaryExpression':\n      ast.argument = remapAst(ast.argument, res);\n      return res(ast);\n    case 'TemplateLiteral':\n      ast.parts = ast.parts.map(([type, value]) => {\n        return type === 'expression'\n          ? [type, remapAst(value, res)]\n          : [type, value];\n      });\n      return res(ast);\n    case 'ComputedProperty':\n      ast.expression = remapAst(ast.expression, res);\n      return res(ast);\n    case 'ArrayLiteral':\n      ast.elements = ast.elements.map((el) => remapAst(el, res));\n      return res(ast);\n    case 'ObjectLiteral':\n      ast.properties = ast.properties.map(({ name, value }) => {\n        return {\n          name: remapAst(name, res),\n          value: value ? remapAst(value, res) : value,\n        };\n      });\n      return res(ast);\n    case 'ArrowFunction':\n      return res(ast);\n  }\n}\n\nexport function genCode(\n  ast: TExpression,\n  res: (ident: string) => string = (s) => s,\n): string {\n  switch (ast.type) {\n    case 'Literal':\n      return res(ast.raw);\n    case 'Identifier':\n      return res(ast.name);\n    case 'CallExpression':\n      return `${res(ast.callee.name)}(${ast.arguments\n        .map((el) => genCode(el, res))\n        .join(', ')})`;\n    case 'BinaryExpression':\n      return `${genCode(ast.left, res)} ${ast.operator} ${genCode(\n        ast.right,\n        res,\n      )}`;\n    case 'ConditionalExpression':\n      return `${genCode(ast.test, res)} ? ${genCode(\n        ast.consequent,\n        res,\n      )} : ${genCode(ast.alternate, res)}`;\n    case 'UnaryExpression':\n      return `${ast.operator}${genCode(ast.argument, res)}`;\n    case 'TemplateLiteral':\n      return (\n        '`' +\n        ast.parts\n          .map(([kind, value]) => {\n            if (kind === 'chunks') {\n              return value; // Hmm...\n            } else {\n              return '${' + genCode(value, res) + '}';\n            }\n          })\n          .join('') +\n        '`'\n      );\n    case 'ComputedProperty':\n      return '[' + genCode(ast.expression, res) + ']';\n    case 'ArrayLiteral':\n      return '[' + ast.elements.map((el) => genCode(el, res)).join(', ') + ']';\n    case 'ObjectLiteral':\n      return (\n        '{' +\n        ast.properties\n          .map((prop) => {\n            if (!prop.value) {\n              return `${genCode(prop.name, res)}`;\n            }\n            return `${genCode(prop.name, res)}: ${genCode(prop.value, res)}`;\n          })\n          .join(', ') +\n        '}'\n      );\n    case 'ArrowFunction':\n      return `(${ast.parameters.map((p) => p.name).join(', ')}) => ${genCode(\n        ast.result,\n        res,\n      )}`;\n  }\n}\n\nexport function rewriteCode(code: string, res: (ident: string) => string) {\n  return genCode(parseExpr(code), res);\n}\n\nexport function executeAst(\n  ast: TExpression,\n  ctx: TExprContext = createExprContext({}),\n  scope: TScope,\n): TExprValue {\n  switch (ast.type) {\n    case 'Literal':\n      return ast.value;\n    case 'Identifier':\n      const value = ctx.get(scope, ast.name);\n      return value !== undefined ? value : ast.name;\n    case 'CallExpression':\n      const fdef = Object.keys(ctx.funcs).includes(ast.callee.name)\n        ? ctx.funcs[ast.callee.name]\n        : null;\n      if (fdef && fdef.lazy) {\n        return fdef.f(ctx, scope, ...ast.arguments);\n      }\n      const args: TExprValue[] = [];\n      if (fdef && fdef.assignment && ast.arguments.length > 1) {\n        const left = exprToIdentifier(ast.arguments[0]!) ?? '';\n        const right = ast.arguments.slice(1);\n        args.push(left, ...right.map((expr) => executeAst(expr, ctx, scope)));\n      } else {\n        args.push(...ast.arguments.map((expr) => executeAst(expr, ctx, scope)));\n      }\n      if (fdef) {\n        const result = fdef.f(ctx, scope, ...args);\n        return result;\n      }\n      if (ctx.call) {\n        return ctx.call(ctx, scope, ast.callee.name, args);\n      }\n      throw new Error(`Function not found: '${ast.callee.name}'`);\n    case 'BinaryExpression':\n      const binop = Object.keys(ctx.binops).includes(ast.operator)\n        ? ctx.binops[ast.operator]\n        : null;\n      if (binop) {\n        return executeAst(\n          {\n            type: 'CallExpression',\n            callee: {\n              name: binop.alias,\n              type: 'Identifier',\n            },\n            arguments: [ast.left, ast.right],\n          },\n          ctx,\n          scope,\n        );\n      }\n      throw new Error(`Operator not found: '${ast.operator}'`);\n    case 'ConditionalExpression':\n      const result = executeAst(ast.test, ctx, scope);\n      if (toBoolean(result)) {\n        return executeAst(ast.consequent, ctx, scope);\n      }\n      return executeAst(ast.alternate, ctx, scope);\n    case 'UnaryExpression':\n      const unop = Object.keys(ctx.unops).includes(ast.operator)\n        ? ctx.unops[ast.operator]\n        : null;\n      if (unop) {\n        return executeAst(\n          {\n            type: 'CallExpression',\n            callee: {\n              name: unop.alias,\n              type: 'Identifier',\n            },\n            arguments: [ast.argument],\n          },\n          ctx,\n          scope,\n        );\n      }\n      throw new Error(`Operator not found: '${ast.operator}'`);\n    case 'TemplateLiteral':\n      let accum = '';\n      for (let i = 0; i < ast.parts.length; i++) {\n        const [kind, value] = ast.parts[i]!;\n        if (kind === 'chunks') {\n          accum += value;\n        } else if (kind === 'expression') {\n          accum += executeAst(value, ctx, scope) + '';\n        }\n      }\n      return accum;\n    case 'ComputedProperty':\n      return executeAst(ast.expression, ctx, scope);\n    case 'ArrayLiteral':\n      return ast.elements.map((element) => executeAst(element, ctx, scope));\n    case 'ObjectLiteral':\n      const obj = {};\n      for (let i = 0; i < ast.properties.length; i++) {\n        const { name, value } = ast.properties[i]!;\n        let key: string = '';\n        if (name.type === 'ComputedProperty') {\n          key = toString(executeAst(name.expression, ctx, scope));\n        } else if (name.type === 'Identifier') {\n          key = name.name; // Don't evaluate this if 'bare'\n        } else if (name.type === 'Literal') {\n          key = name.value;\n        }\n        obj[key] = executeAst(value ? value : name, ctx, scope);\n      }\n      return obj;\n    case 'ArrowFunction':\n      return {\n        params: ast.parameters.map(({ name }) => name),\n        body: ast.result,\n      } as any;\n    default:\n      console.info(ast);\n      throw new Error(`Syntax error`);\n  }\n}\n\nexport function exprToIdentifier(v: TExpression): string | null {\n  if (v.type === 'Identifier') {\n    return v.name;\n  }\n  return null;\n}\n\nexport function toNumber(v: any, fallback: number = 0): number {\n  if (typeof v === 'boolean') {\n    return v ? 1 : 0;\n  }\n  if (typeof v === 'number') {\n    return isNaN(v) ? fallback : v;\n  }\n  if (typeof v === 'string') {\n    if (v.includes('.')) {\n      return parseFloat(v);\n    }\n    return parseInt(v);\n  }\n  return fallback;\n}\n\nexport function toBoolean(v: TExprValue): boolean {\n  if (!v) {\n    return false;\n  }\n  if (typeof v === 'string' && v.match(/^\\s+$/)) {\n    return false;\n  }\n  if (v === 'false') {\n    return false;\n  }\n  if (v === '0') {\n    return false;\n  }\n  return true;\n}\n\nexport function toString(v: any): string {\n  if (typeof v === 'number') {\n    return v.toString(10);\n  }\n  if (v === true || v === 'true') {\n    return 'true';\n  }\n  if (!v) {\n    return '';\n  }\n  return v + '';\n}\n\nexport function toObject(v: any): TExprObject {\n  if (!v) {\n    return {};\n  }\n  if (v && typeof v === 'object') {\n    return v;\n  }\n  return {};\n}\n\nexport function toArray(v: any): TExprArray {\n  if (!v) {\n    return [];\n  }\n  if (Array.isArray(v)) {\n    return v.map((e) => toScalar(e));\n  }\n  if (v && typeof v === 'object') {\n    return Object.keys(v).map((k) => toScalar(v[k]));\n  }\n  if (\n    typeof v === 'number' ||\n    typeof v === 'string' ||\n    typeof v === 'boolean'\n  ) {\n    return [v];\n  }\n  return [];\n}\n\nexport function toScalar(n: any, radix: number = 10): TExprScalar {\n  if (typeof n === 'number') {\n    return n;\n  }\n  if (typeof n === 'string') {\n    return n;\n  }\n  if (typeof n === 'boolean') {\n    return n;\n  }\n  if (!n) {\n    return null;\n  }\n  if (typeof n === 'object') {\n    return '';\n  }\n  return n + '';\n}\n\nfunction setVar<T extends TExprValue>(\n  ctx: TExprContext,\n  scope: TScope,\n  name: any,\n  value: T,\n): T {\n  const key = toString(name);\n  ctx.set(scope, key, value);\n  return value;\n}\n\nfunction getVar(ctx: TExprContext, scope: TScope, name: any): TExprValue {\n  return ctx.get(scope, name + '') ?? null;\n}\n\nexport const STDLIB: DictOf<TExprFuncDef> = {\n  do: {\n    f(ctx, scope, ...args) {\n      return args[args.length - 1] ?? null;\n    },\n  },\n  present: {\n    f(ctx, scope, v) {\n      return !!v;\n    },\n  },\n  empty: {\n    f(ctx, scope, v) {\n      if (Array.isArray(v)) {\n        return v.length < 1;\n      }\n      if (v && typeof v === 'object') {\n        return Object.keys(v).length < 1;\n      }\n      return !v;\n    },\n  },\n  blank: {\n    f(ctx, scope, v) {\n      if (Array.isArray(v)) {\n        return v.length < 1;\n      }\n      if (v && typeof v === 'object') {\n        return Object.keys(v).length < 1;\n      }\n      if (typeof v === 'string' && (!v || v.match(/^\\s+$/))) {\n        return true;\n      }\n      return !v;\n    },\n  },\n  setVar: {\n    assignment: true,\n    f(ctx, scope, left, right) {\n      return setVar(ctx, scope, left, right);\n    },\n  },\n  setAdd: {\n    assignment: true,\n    f(ctx, scope, left, right) {\n      const lval = getVar(ctx, scope, left);\n      if (typeof lval === 'string') {\n        return setVar(ctx, scope, left, lval + right + '');\n      }\n      return setVar(ctx, scope, left, toNumber(lval) + toNumber(right));\n    },\n  },\n  setSub: {\n    assignment: true,\n    f(ctx, scope, left, right) {\n      return setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(getVar(ctx, scope, left)) - toNumber(right),\n      );\n    },\n  },\n  setMul: {\n    assignment: true,\n    f(ctx, scope, left, right) {\n      return setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(getVar(ctx, scope, left)) * toNumber(right),\n      );\n    },\n  },\n  setDiv: {\n    assignment: true,\n    f(ctx, scope, left, right) {\n      return setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(getVar(ctx, scope, left)) / toNumber(right),\n      );\n    },\n  },\n  nullCoalesce: {\n    f(ctx, scope, a, b) {\n      return a ?? b;\n    },\n  },\n  unixTimestampNow: {\n    f() {\n      return Date.now();\n    },\n  },\n  unixTimestampForDate: {\n    f(ctx, scope, year, mon, day, hour, min, second) {\n      return new Date(\n        toNumber(year),\n        toNumber(mon),\n        toNumber(day),\n        toNumber(hour),\n        toNumber(min),\n        toNumber(second),\n      ).getTime();\n    },\n  },\n  all: {\n    f(ctx, scope, xs) {\n      if (!Array.isArray(xs)) {\n        return !!xs;\n      }\n      for (let i = 0; i < xs.length; i++) {\n        if (!xs[i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n  },\n  any: {\n    f(ctx, scope, xs) {\n      if (!Array.isArray(xs)) {\n        return !!xs;\n      }\n      for (let i = 0; i < xs.length; i++) {\n        if (xs[i]) {\n          return true;\n        }\n      }\n      return false;\n    },\n  },\n  some: {\n    f(ctx, scope, xs) {\n      return !!STDLIB['any']!.f(ctx, scope, xs as any);\n    },\n  },\n  none: {\n    f(ctx, scope, xs) {\n      return !STDLIB['any']!.f(ctx, scope, xs as any);\n    },\n  },\n  or: {\n    f(ctx, scope, a, b) {\n      return toBoolean(a) || toBoolean(b);\n    },\n  },\n  and: {\n    f(ctx, scope, a, b) {\n      return toBoolean(a) && toBoolean(b);\n    },\n  },\n  not: {\n    f(ctx, scope, a) {\n      return !toBoolean(a);\n    },\n  },\n  gt: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  gte: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  lt: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  lte: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  eq: {\n    f(ctx, scope, a, b) {\n      return toString(a) === toString(b);\n    },\n  },\n  neq: {\n    f(ctx, scope, a, b) {\n      return toString(a) !== toString(b);\n    },\n  },\n  rand: {\n    f(ctx) {\n      return ctx.rng();\n    },\n  },\n  randInRange: {\n    f(ctx, scope, min, max) {\n      return ctx.rng() * (Number(max) - Number(min)) + Number(min);\n    },\n  },\n  randInt: {\n    f(ctx) {\n      return Math.floor(ctx.rng() * 10);\n    },\n  },\n  randIntInRange: {\n    f(ctx, scope, min, max) {\n      min = Math.ceil(Number(min));\n      max = Math.floor(Number(max));\n      return Math.floor(ctx.rng() * (max - min + 1)) + min;\n    },\n  },\n  number: {\n    f(ctx, scope, a) {\n      return Number(a);\n    },\n  },\n  isNumeric: {\n    f(ctx, scope, a) {\n      if (typeof a === 'number') {\n        return true;\n      }\n      if (typeof a === 'string') {\n        return isNumeric(a);\n      }\n      return false;\n    },\n  },\n  bitwiseOr: {\n    f(ctx, scope, a, b) {\n      return Number(a) | Number(b);\n    },\n  },\n  bitwiseXor: {\n    f(ctx, scope, a, b) {\n      return Number(a) ^ Number(b);\n    },\n  },\n  bitwiseAnd: {\n    f(ctx, scope, a, b) {\n      return Number(a) & Number(b);\n    },\n  },\n  bitwiseNot: {\n    f(ctx, scope, a) {\n      return ~Number(a);\n    },\n  },\n  bitwiseLeftShift: {\n    f(ctx, scope, a, b) {\n      return Number(a) << Number(b);\n    },\n  },\n  bitwiseRightShift: {\n    f(ctx, scope, a, b) {\n      return Number(a) >> Number(b);\n    },\n  },\n  bitwiseRightshiftUnsigned: {\n    f(ctx, scope, a, b) {\n      return Number(a) >>> Number(b);\n    },\n  },\n  negate: {\n    f(ctx, scope, a) {\n      return -toNumber(a);\n    },\n  },\n  add: {\n    f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a + b + '';\n      }\n      return toNumber(a) + toNumber(b);\n    },\n  },\n  sub: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) - toNumber(b);\n    },\n  },\n  div: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) / toNumber(b);\n    },\n  },\n  mul: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) * toNumber(b);\n    },\n  },\n  mod: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) % toNumber(b);\n    },\n  },\n  pow: {\n    f(ctx, scope, a, b) {\n      return Math.pow(toNumber(a), toNumber(b));\n    },\n  },\n  abs: {\n    f(ctx, scope, a) {\n      return Math.abs(toNumber(a));\n    },\n  },\n  acos: {\n    f(ctx, scope, a) {\n      return Math.acos(toNumber(a));\n    },\n  },\n  acosh: {\n    f(ctx, scope, a) {\n      return Math.acosh(toNumber(a));\n    },\n  },\n  asin: {\n    f(ctx, scope, a) {\n      return Math.asin(toNumber(a));\n    },\n  },\n  asinh: {\n    f(ctx, scope, a) {\n      return Math.asinh(toNumber(a));\n    },\n  },\n  atan: {\n    f(ctx, scope, a) {\n      return Math.atan(toNumber(a));\n    },\n  },\n  atan2: {\n    f(ctx, scope, a, b) {\n      return Math.atan2(toNumber(a), toNumber(b));\n    },\n  },\n  atanh: {\n    f(ctx, scope, a) {\n      return Math.atanh(toNumber(a));\n    },\n  },\n  cbrt: {\n    f(ctx, scope, a) {\n      return Math.cbrt(toNumber(a));\n    },\n  },\n  ceil: {\n    f(ctx, scope, a) {\n      return Math.ceil(toNumber(a));\n    },\n  },\n  cos: {\n    f(ctx, scope, a) {\n      return Math.cos(toNumber(a));\n    },\n  },\n  cosh: {\n    f(ctx, scope, a) {\n      return Math.cosh(toNumber(a));\n    },\n  },\n  exp: {\n    f(ctx, scope, a) {\n      return Math.exp(toNumber(a));\n    },\n  },\n  floor: {\n    f(ctx, scope, a) {\n      return Math.floor(toNumber(a));\n    },\n  },\n  hypot: {\n    f(ctx, scope, a) {\n      return Math.hypot(toNumber(a));\n    },\n  },\n  log: {\n    f(ctx, scope, a) {\n      return Math.log(toNumber(a));\n    },\n  },\n  log10: {\n    f(ctx, scope, a) {\n      return Math.log10(toNumber(a));\n    },\n  },\n  log2: {\n    f(ctx, scope, a) {\n      return Math.log2(toNumber(a));\n    },\n  },\n  max: {\n    f(ctx, scope, a) {\n      return Math.max(toNumber(a));\n    },\n  },\n  min: {\n    f(ctx, scope, a) {\n      return Math.min(toNumber(a));\n    },\n  },\n  round: {\n    f(ctx, scope, a) {\n      return Math.round(toNumber(a));\n    },\n  },\n  sign: {\n    f(ctx, scope, a) {\n      return Math.sign(toNumber(a));\n    },\n  },\n  sin: {\n    f(ctx, scope, a) {\n      return Math.sin(toNumber(a));\n    },\n  },\n  sinh: {\n    f(ctx, scope, a) {\n      return Math.sinh(toNumber(a));\n    },\n  },\n  sqrt: {\n    f(ctx, scope, a) {\n      return Math.sqrt(toNumber(a));\n    },\n  },\n  tan: {\n    f(ctx, scope, a) {\n      return Math.tan(toNumber(a));\n    },\n  },\n  tanh: {\n    f(ctx, scope, a) {\n      return Math.tanh(toNumber(a));\n    },\n  },\n  trunc: {\n    f(ctx, scope, a) {\n      return Math.trunc(toNumber(a));\n    },\n  },\n  fromCharCode: {\n    f(ctx, scope, a) {\n      return String.fromCharCode(Number(a));\n    },\n  },\n  fromCodePoint: {\n    f(ctx, scope, a) {\n      return String.fromCodePoint(Number(a));\n    },\n  },\n  parseInt: {\n    f(ctx, scope, a, b) {\n      return parseInt(toString(a), Number(b));\n    },\n  },\n  parseFloat: {\n    f(ctx, scope, a) {\n      return parseFloat(toString(a));\n    },\n  },\n  charAt: {\n    f(ctx, scope, a, b) {\n      return toString(a).charAt(Number(b));\n    },\n  },\n  charCodeAt: {\n    f(ctx, scope, a, b) {\n      return toString(a).charCodeAt(Number(b));\n    },\n  },\n  codePointAt: {\n    f(ctx, scope, a, b) {\n      return toString(a).codePointAt(Number(b)) ?? 0;\n    },\n  },\n  localeCompare: {\n    f(ctx, scope, a, b) {\n      return toString(a).localeCompare(toString(b));\n    },\n  },\n  match: {\n    f(ctx, scope, a, b) {\n      return !!toString(a).match(toString(b));\n    },\n  },\n  matchAll: {\n    f(ctx, scope, a, b) {\n      return !!toString(a).match(toString(b));\n    },\n  },\n  padEnd: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).padEnd(Number(b), toString(c ?? ''));\n    },\n  },\n  padStart: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).padStart(Number(b), toString(c ?? ''));\n    },\n  },\n  repeat: {\n    f(ctx, scope, a, b) {\n      return toString(a).repeat(Number(b));\n    },\n  },\n  replace: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).replace(toString(b), toString(c));\n    },\n  },\n  replaceAll: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).replaceAll(toString(b), toString(c));\n    },\n  },\n  startsWith: {\n    f(ctx, scope, a, b) {\n      return toString(a).startsWith(toString(b));\n    },\n  },\n  substring: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).substring(Number(b), Number(c));\n    },\n  },\n  toLowerCase: {\n    f(ctx, scope, a) {\n      return toString(a).toLowerCase();\n    },\n  },\n  toUpperCase: {\n    f(ctx, scope, a) {\n      return toString(a).toUpperCase();\n    },\n  },\n  trim: {\n    f(ctx, scope, a) {\n      return toString(a).trim();\n    },\n  },\n  trimEnd: {\n    f(ctx, scope, a) {\n      return toString(a).trimEnd();\n    },\n  },\n  trimStart: {\n    f(ctx, scope, a) {\n      return toString(a).trimStart();\n    },\n  },\n  clamp: {\n    f(ctx, a, min, max) {\n      return clamp(toNumber(a), toNumber(min), toNumber(max));\n    },\n  },\n  avg: {\n    f(ctx, scope, nn) {\n      return avg(toArray(nn).map((n) => toNumber(n)));\n    },\n  },\n  sum: {\n    f(ctx, scope, nn) {\n      return sum(toArray(nn).map((n) => toNumber(n)));\n    },\n  },\n  join: {\n    f(ctx, scope, ss, spacer) {\n      return toArray(ss).join(toString(spacer));\n    },\n  },\n  split: {\n    f(ctx, scope, s, spacer) {\n      return toString(s).split(toString(spacer));\n    },\n  },\n  first: {\n    f(ctx, scope, arr) {\n      if (typeof arr === 'string') {\n        return arr[0] ?? null;\n      }\n      return toArray(arr)[0] ?? null;\n    },\n  },\n  last: {\n    f(ctx, scope, arr) {\n      if (typeof arr === 'string') {\n        return arr[arr.length] ?? null;\n      }\n      arr = toArray(arr);\n      return arr[arr.length] ?? null;\n    },\n  },\n  length: {\n    f(ctx, scope, arr) {\n      if (typeof arr === 'string') {\n        return arr.length;\n      }\n      return toArray(arr).length;\n    },\n  },\n  concat: {\n    f(ctx, scope, aa, bb) {\n      if (typeof aa === 'string') {\n        return aa + toString(bb);\n      }\n      return [...toArray(aa), ...toArray(bb)];\n    },\n  },\n  endsWith: {\n    f(ctx, scope, a, b, c = '') {\n      if (Array.isArray(a)) {\n        a = a.join(toString(c));\n      }\n      return toString(a).endsWith(toString(b));\n    },\n  },\n  includes: {\n    f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a.includes(toString(b));\n      }\n      return toArray(a).includes(b);\n    },\n  },\n  lastIndexOf: {\n    f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a.lastIndexOf(toString(b));\n      }\n      return toArray(a).lastIndexOf(b);\n    },\n  },\n  indexOf: {\n    f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a.indexOf(toString(b));\n      }\n      return toArray(a).indexOf(b);\n    },\n  },\n  nth: {\n    f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a[toNumber(b)] ?? null;\n      }\n      return toArray(a)[toNumber(b)] ?? null;\n    },\n  },\n  reverse: {\n    f(ctx, scope, a) {\n      if (typeof a === 'string') {\n        return a.split('').reverse().join('');\n      }\n      return toArray(a).reverse();\n    },\n  },\n  take: {\n    f(ctx, scope, a, n) {\n      if (typeof a === 'string') {\n        return a.slice(0, toNumber(n));\n      }\n      return toArray(a).slice(0, toNumber(n));\n    },\n  },\n  head: {\n    f(ctx, scope, arr) {\n      return toArray(arr).slice(0, -1);\n    },\n  },\n  tail: {\n    f(ctx, scope, arr) {\n      return toArray(arr).slice(1);\n    },\n  },\n  slice: {\n    f(ctx, scope, arr, a, b) {\n      if (typeof arr === 'string') {\n        return arr.slice(toNumber(a), toNumber(b));\n      }\n      return toArray(arr).slice(toNumber(a), toNumber(b));\n    },\n  },\n  randEl: {\n    f(ctx, scope, arr) {\n      arr = toArray(arr);\n      const i = STDLIB['randIntInRange']!.f(\n        ctx,\n        scope,\n        0 as any,\n        (arr.length - 1) as any,\n      ) as number;\n      return arr[i] ?? null;\n    },\n  },\n  push: {\n    f(ctx, scope, arr, value) {\n      if (Array.isArray(arr)) {\n        arr.push(value);\n        return arr.length;\n      }\n      return -1;\n    },\n  },\n  pop: {\n    f(ctx, scope, arr) {\n      if (Array.isArray(arr)) {\n        return arr.pop() ?? null;\n      }\n      return null;\n    },\n  },\n  shift: {\n    f(ctx, scope, arr) {\n      if (Array.isArray(arr)) {\n        return arr.shift() ?? null;\n      }\n      return null;\n    },\n  },\n  unshift: {\n    f(ctx, scope, arr, value) {\n      if (Array.isArray(arr)) {\n        arr.unshift(value);\n        return arr.length;\n      }\n      return -1;\n    },\n  },\n  keysOf: {\n    f(ctx, scope, obj) {\n      return Object.keys(toObject(obj));\n    },\n  },\n  valuesOf: {\n    f(ctx, scope, obj) {\n      return Object.values(toObject(obj));\n    },\n  },\n  getProperty: {\n    f(ctx, scope, obj, key) {\n      return toObject(obj)[toString(key)] ?? null;\n    },\n  },\n  setProperty: {\n    f(ctx, scope, obj, key, value) {\n      if (obj && typeof obj === 'object') {\n        obj[toString(key)] = value;\n      }\n      return obj;\n    },\n  },\n  map: {\n    f(ctx, scope, arr, mapper) {\n      arr = toArray(arr);\n      const func = asFunc(mapper);\n      if (!func) {\n        return arr;\n      }\n      const { params, body } = func;\n      return arr.map((el, idx, coll) => {\n        const subscope = {\n          ...scope,\n          [params[0] ?? '__element__']: el,\n          [params[1] ?? '__index__']: idx,\n          [params[2] ?? '__collection__']: coll,\n        };\n        return executeAst(\n          body,\n          {\n            ...ctx,\n            get(scope, key) {\n              if (scope[key] !== undefined) {\n                return scope[key] ?? null;\n              }\n              return ctx.get(scope, key);\n            },\n          },\n          subscope,\n        );\n      });\n    },\n  },\n  filter: {\n    f(ctx, scope, arr, mapper) {\n      arr = toArray(arr);\n      const func = asFunc(mapper);\n      if (!func) {\n        return arr;\n      }\n      const { params, body } = func;\n      return arr.filter((el, idx, coll) => {\n        const subscope = {\n          ...scope,\n          [params[0] ?? '__element__']: el,\n          [params[1] ?? '__index__']: idx,\n          [params[2] ?? '__collection__']: coll,\n        };\n        return toBoolean(\n          executeAst(\n            body,\n            {\n              ...ctx,\n              get(scope, key) {\n                if (scope[key] !== undefined) {\n                  return scope[key] ?? null;\n                }\n                return ctx.get(scope, key);\n              },\n            },\n            subscope,\n          ),\n        );\n      });\n    },\n  },\n};\n\nfunction asFunc(v: any): { body: TExpression; params: string[] } | undefined {\n  if (v && typeof v === 'object') {\n    const { params, body } = v as any;\n    if (\n      Array.isArray(params) &&\n      body &&\n      typeof body === 'object' &&\n      typeof body['type'] === 'string'\n    ) {\n      return { body, params };\n    }\n  }\n  return;\n}\n\n// The code below is derived from code at https://github.com/dmaevsky/rd-parse. License:\n// The MIT License (MIT)\n// Copyright 2013 - present Dmitry Maevsky\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst associativity = (binop) => (binop === '**' ? r2l : l2r);\n\nfunction locAt(text, newPos, { pos, line, column }) {\n  while (pos < newPos) {\n    const ch = text[pos++];\n    if (ch === '\\n') {\n      column = 1;\n      line++;\n    } else {\n      column++;\n    }\n  }\n  return { pos, line, column };\n}\n\nconst markSeen = ($) => {\n  if ($.pos > $.lastSeen.pos) {\n    Object.assign($.lastSeen, locAt($.text, $.pos, $.lastSeen));\n  }\n};\n\nfunction RegexToken(pattern) {\n  return ($) => {\n    markSeen($);\n    const match = pattern.exec($.text.substring($.pos));\n    if (!match) {\n      return $;\n    }\n    const $next = {\n      ...$,\n      pos: $.pos + match[0].length,\n    };\n    for (let i = 1; i < match.length; i++) {\n      $.stack[$next.sp++] = match[i];\n    }\n    return $next;\n  };\n}\n\nfunction StringToken(pattern) {\n  return ($) => {\n    markSeen($);\n    if ($.text.startsWith(pattern, $.pos)) {\n      return {\n        ...$,\n        pos: $.pos + pattern.length,\n      };\n    }\n    return $;\n  };\n}\n\nfunction Use(rule) {\n  if (typeof rule === 'function') {\n    return rule;\n  }\n  if (rule instanceof RegExp) {\n    return RegexToken(rule);\n  }\n  if (typeof rule === 'string') {\n    return StringToken(rule);\n  }\n  throw new Error('Invalid rule');\n}\n\nfunction Ignore(toIgnore, rule) {\n  rule = Use(rule);\n  if (toIgnore) {\n    toIgnore = Ignore(null, Plus(toIgnore));\n  }\n\n  return ($) => {\n    const $cur = toIgnore ? toIgnore($) : $;\n    $.ignore.push(toIgnore);\n    const $next = rule($cur);\n    $.ignore.pop();\n    return $next === $cur ? $ : toIgnore ? toIgnore($next) : $next;\n  };\n}\n\nconst skipIgnored = ($) => {\n  if (!$.ignore.length) {\n    return $;\n  }\n  const toIgnore = $.ignore[$.ignore.length - 1];\n  return toIgnore ? toIgnore($) : $;\n};\n\nfunction All(...rules) {\n  rules = rules.map(Use);\n  return ($) => {\n    let $cur = $;\n    for (let i = 0; i < rules.length; i++) {\n      const $before = i > 0 ? skipIgnored($cur) : $cur;\n      const $after = rules[i]($before);\n      if ($after === $before) {\n        return $;\n      }\n      if ($after.pos > $before.pos || $after.sp > $before.sp) {\n        $cur = $after;\n      }\n    }\n    return $cur;\n  };\n}\n\nfunction Any(...rules) {\n  rules = rules.map(Use);\n  return ($) => {\n    for (let i = 0; i < rules.length; i++) {\n      const $next = rules[i]($);\n      if ($next !== $) {\n        return $next;\n      }\n    }\n    return $;\n  };\n}\n\nfunction Plus(rule) {\n  rule = Use(rule);\n  return ($) => {\n    while (true) {\n      const $cur = skipIgnored($);\n      const $next = rule($cur);\n      if ($next === $cur) {\n        return $;\n      }\n      $ = $next;\n    }\n  };\n}\n\nfunction Optional(rule) {\n  rule = Use(rule);\n  return ($) => {\n    const $next = rule($);\n    if ($next !== $) {\n      return $next;\n    }\n    return { ...$ };\n  };\n}\n\nfunction Node(rule, reducer) {\n  rule = Use(rule);\n  return ($) => {\n    const $next = rule($);\n    if ($next === $) {\n      return $;\n    }\n    const node = reducer($.stack.slice($.sp, $next.sp), $, $next);\n    $next.sp = $.sp;\n    if (node !== null) {\n      $.stack[$next.sp++] = node;\n    }\n    return $next;\n  };\n}\n\nconst Star = (rule) => Optional(Plus(rule));\n\nconst Y = (proc) => ((x) => proc((y) => x(x)(y)))((x) => proc((y) => x(x)(y)));\n\nconst START = (text, pos = 0) => ({\n  text,\n  ignore: [],\n  stack: [],\n  sp: 0,\n  lastSeen: locAt(text, pos, { pos: 0, line: 1, column: 1 }),\n  pos,\n});\n\nfunction Parser(\n  Grammar,\n  pos = 0,\n  partial = false,\n): (text: string) => TExpression {\n  return (text) => {\n    if (typeof text !== 'string') {\n      throw new Error('Parsing function expects a string input');\n    }\n    const $ = START(text, pos);\n    const $next = Grammar($);\n    if ($ === $next || (!partial && $next.pos < text.length)) {\n      throw new Error(\n        `Unexpected token at ${$.lastSeen.line}:${\n          $.lastSeen.column\n        }. Remainder: ${text.slice($.lastSeen.pos)}`,\n      );\n    }\n    return $.stack[0] as unknown as TExpression;\n  };\n}\n\nfunction l2r(parts, $) {\n  let left = parts[0];\n  for (let i = 1; i < parts.length; i += 2) {\n    const [operator, right] = [parts[i].operator, parts[i + 1]];\n    left = srcMap(\n      {\n        type: 'BinaryExpression',\n        left,\n        operator,\n        right,\n      },\n      $,\n      { pos: right.pos + right.text.length },\n    );\n  }\n  return left;\n}\n\nfunction r2l(parts, _, $next) {\n  let right = parts[parts.length - 1];\n  for (let i = parts.length - 2; i >= 0; i -= 2) {\n    const [left, operator] = [parts[i - 1], parts[i].operator];\n    right = srcMap(\n      {\n        type: 'BinaryExpression',\n        left,\n        operator,\n        right,\n      },\n      { pos: left.pos },\n      $next,\n    );\n  }\n  return right;\n}\n\nconst Operator = (Rule) =>\n  Node(Rule, (_, $, $next) => ({\n    $,\n    operator: $.text.substring($.pos, $next.pos),\n  }));\n\nconst srcMap = (obj, $, $next) =>\n  Object.defineProperties(obj, {\n    pos: { writable: true, configurable: true, value: $.pos },\n    text: {\n      writable: true,\n      configurable: true,\n      value: ($.text || $next.text).slice($.pos, $next.pos),\n    },\n  });\n\nconst DefaultGrammar = IgnoreWhitespace(\n  Y((Expression) => {\n    const Identifier = Node(IdentifierToken, ([name]) => ({\n      type: 'Identifier',\n      name,\n    }));\n    const StringLiteral = Node(QuoteToken, ([raw]) => ({\n      type: 'Literal',\n      value: raw.slice(1, -1),\n      raw,\n    }));\n    const NumericLiteral = Node(NumericToken, ([raw]) => ({\n      type: 'Literal',\n      value: +raw,\n      raw,\n    }));\n    const NullLiteral = Node(NullToken, ([raw]) => ({\n      type: 'Literal',\n      value: null,\n      raw,\n    }));\n    const BooleanLiteral = Node(BooleanToken, ([raw]) => ({\n      type: 'Literal',\n      value: raw === 'true',\n      raw,\n    }));\n    const InterpolationChunk = Node(InterpolationChunkToken, ([raw]) => [\n      'chunks',\n      raw,\n    ]);\n    const TemplateInlineExpression = Node(\n      All('${', IgnoreWhitespace(Expression), '}'),\n      ([expression]) => ['expression', expression],\n    );\n    const TemplateLiteral = Node(\n      Ignore(\n        null,\n        All('`', Star(Any(InterpolationChunk, TemplateInlineExpression)), '`'),\n      ),\n      (parts) => ({ type: 'TemplateLiteral', parts }),\n    );\n    const Literal = Any(\n      StringLiteral,\n      NumericLiteral,\n      NullLiteral,\n      BooleanLiteral,\n      TemplateLiteral,\n    );\n    const ArgumentsList = All(Expression, Star(All(',', Expression)));\n    const Arguments = Node(\n      All('(', Optional(All(ArgumentsList, Optional(','))), ')'),\n      (args) => ({\n        args,\n      }),\n    );\n    const ArgumentsExpression = Node(Any(Arguments), ([part], _, $next) => ({\n      part,\n      $next,\n    }));\n    const CompoundExpression = Node(\n      All(Expression, Star(All(',', Expression))),\n      (leafs) =>\n        leafs.length > 1 ? { type: 'CompoundExpression', leafs } : leafs[0],\n    );\n    const ComputedPropertyName = Node(\n      All('[', CompoundExpression, ']'),\n      ([expression]) => ({ type: 'ComputedProperty', expression }),\n    );\n    const PropertyName = Any(\n      Identifier,\n      StringLiteral,\n      NumericLiteral,\n      ComputedPropertyName,\n    );\n    const ShortNotation = Node(Identifier, ([expr], $, $next) =>\n      srcMap({ ...expr, shortNotation: true }, $, $next),\n    );\n    const PropertyDefinition = Node(\n      Any(All(PropertyName, ':', Expression), ShortNotation),\n      ([name, value]) => ({\n        name,\n        value,\n      }),\n    );\n    const PropertyDefinitions = All(\n      PropertyDefinition,\n      Star(All(',', PropertyDefinition)),\n    );\n    const PropertyDefinitionList = Optional(\n      All(PropertyDefinitions, Optional(',')),\n    );\n    const ObjectLiteral = Node(\n      All('{', PropertyDefinitionList, '}'),\n      (properties) => ({ type: 'ObjectLiteral', properties }),\n    );\n    const Element = Any(Expression);\n    const ElementList = All(Element, Star(All(',', Element)));\n    const ArrayLiteral = Node(\n      All('[', Optional(ElementList), ']'),\n      (elements) => ({\n        type: 'ArrayLiteral',\n        elements,\n      }),\n    );\n    const PrimaryExpression = Node(\n      Any(\n        Literal,\n        Identifier,\n        ArrayLiteral,\n        ObjectLiteral,\n        All('(', CompoundExpression, ')'),\n      ),\n      ([expr], $, $next) => srcMap(expr, $, $next),\n    );\n    const CallExpression = Node(\n      All(PrimaryExpression, Star(ArgumentsExpression)),\n      (parts, $, $last) => {\n        return parts.reduce((acc, { part, $next }) => {\n          return srcMap(\n            { type: 'CallExpression', callee: acc, arguments: part.args },\n            $,\n            $next,\n          );\n        });\n      },\n    );\n    const UnaryOperator = Operator(Any('+', '-', '~', '!'));\n    const UnaryExpression = Node(\n      All(Star(UnaryOperator), CallExpression),\n      (parts, _, $next) =>\n        parts.reduceRight((argument, { $, operator }) =>\n          srcMap({ type: 'UnaryExpression', argument, operator }, $, $next),\n        ),\n    );\n    const LogicalExpressionOrExpression = BinaryOperatorPrecedence.reduce(\n      (Expr, BinaryOp) =>\n        Node(\n          All(Expr, Star(All(Operator(BinaryOp), Expr))),\n          associativity(BinaryOp),\n        ),\n      UnaryExpression,\n    );\n    const TernaryExpression = Node(\n      All(\n        LogicalExpressionOrExpression,\n        Optional(All('?', Expression, ':', Expression)),\n      ),\n      ([test, consequent, alternate]) => {\n        return consequent\n          ? { type: 'ConditionalExpression', test, consequent, alternate }\n          : test;\n      },\n    );\n    const BoundName = Node(IdentifierToken, ([name], $, $next) =>\n      srcMap({ type: 'BoundName', name }, $, $next),\n    );\n    const FormalsList = Node(\n      All(BoundName, Star(All(',', BoundName))),\n      (bound) => bound,\n    );\n    const FormalParameters = Node(All('(', All(FormalsList), ')'), (parts) =>\n      parts.reduce((acc, part) => Object.assign(acc, part), []),\n    );\n    const ArrowParameters = Node(\n      Any(BoundName, FormalParameters),\n      ([params]) => params,\n    );\n    const FoolSafe = Node('{', () => {\n      throw new Error(\n        'Object literal returned from the arrow function needs to be enclosed in ()',\n      );\n    });\n    const ArrowResult = Any(FoolSafe, Expression);\n    const ArrowFunction = Node(\n      All(ArrowParameters, '=>', ArrowResult),\n      ([parameters, result]) => ({ type: 'ArrowFunction', parameters, result }),\n    );\n\n    return Node(Any(ArrowFunction, TernaryExpression), ([expr], $, $next) =>\n      srcMap(expr, $, $next),\n    );\n  }),\n);\n\nexport function clamp(n: number, min: number = 0, max: number = 1): number {\n  if (n < min) return min;\n  if (n > max) return max;\n  return n;\n}\nexport function avg(nn: number[]): number {\n  if (nn.length < 1) return 0;\n  return sum(nn) / nn.length;\n}\nexport function sum(nn: number[]): number {\n  let n = 0;\n  for (let i = 0; i < nn.length; i++) n += nn[i]!;\n  return n;\n}\n\nexport function isNumeric(a: any): boolean {\n  return !isNaN(parseFloat(a)) && isFinite(a);\n}\n"],"names":["ZExprScalar","z","union","number","string","boolean","null","CONSTS","E","Math","LN10","LN2","LOG10E","LOG2E","PI","SQRT1_2","SQRT2","BINOP_MAP","alias","UNOP_MAP","IgnoreWhitespace","Rule","Ignore","QuoteToken","Any","NumericToken","NullToken","BooleanToken","IdentifierToken","InterpolationChunkToken","BinaryOperatorPrecedence","INVALID_IDENT_REGEX","createExprContext","_a","funcs","binops","unops","_b","seed","get","set","call","vars","rng","seedrandom","default","__assign","STDLIB","scope","name","match","value","evaluateExpr","code","ctx","result","executeAst","parseExpr","Grammar","pos","partial","text","Error","$","ignore","stack","sp","lastSeen","locAt","line","column","START","$next","length","concat","slice","Parser","DefaultGrammar","parser","replace","genCode","ast","res","s","type","raw","callee","arguments","map","el","join","left","operator","right","test","consequent","alternate","argument","parts","kind","expression","elements","properties","prop","parameters","p","undefined","fdef","Object","keys","includes","lazy","f","apply","__spreadArray","args","assignment","exprToIdentifier","push","expr","binop","toBoolean","unop","accum","i","value_1","element","obj","_c","value_2","key","toString","params","body","console","info","v","toNumber","fallback","isNaN","parseFloat","parseInt","toObject","toArray","Array","isArray","e","toScalar","k","n","radix","setVar","getVar","do","_i","present","empty","blank","setAdd","lval","setSub","setMul","setDiv","nullCoalesce","a","b","unixTimestampNow","Date","now","unixTimestampForDate","year","mon","day","hour","min","second","getTime","all","xs","any","some","none","or","and","not","gt","gte","lt","lte","eq","neq","rand","randInRange","max","Number","randInt","floor","randIntInRange","ceil","isNumeric","bitwiseOr","bitwiseXor","bitwiseAnd","bitwiseNot","bitwiseLeftShift","bitwiseRightShift","bitwiseRightshiftUnsigned","negate","add","sub","div","mul","mod","pow","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","cos","cosh","exp","hypot","log","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc","fromCharCode","String","fromCodePoint","charAt","charCodeAt","codePointAt","localeCompare","matchAll","padEnd","c","padStart","repeat","replaceAll","startsWith","substring","toLowerCase","toUpperCase","trim","trimEnd","trimStart","clamp","avg","nn","sum","ss","spacer","split","first","arr","last","aa","bb","endsWith","lastIndexOf","indexOf","nth","reverse","take","head","tail","randEl","pop","shift","unshift","keysOf","valuesOf","values","getProperty","setProperty","mapper","func","asFunc","idx","coll","subscope","_d","filter","newPos","markSeen","assign","Use","rule","RegExp","pattern","exec","StringToken","toIgnore","Plus","$cur","skipIgnored","All","rules","$before","$after","Optional","Node","reducer","node","Star","l2r","srcMap","r2l","_","proc","x","Operator","defineProperties","writable","configurable","y","Expression","Identifier","StringLiteral","NumericLiteral","NullLiteral","BooleanLiteral","InterpolationChunk","TemplateInlineExpression","TemplateLiteral","Literal","ArgumentsList","Arguments","ArgumentsExpression","part","CompoundExpression","leafs","PropertyName","ShortNotation","shortNotation","PropertyDefinition","PropertyDefinitions","PropertyDefinitionList","ObjectLiteral","Element","ElementList","ArrayLiteral","PrimaryExpression","CallExpression","$last","reduce","acc","UnaryOperator","UnaryExpression","reduceRight","LogicalExpressionOrExpression","Expr","BinaryOp","TernaryExpression","BoundName","FormalsList","bound","FormalParameters","ArrowParameters","FoolSafe","ArrowFunction","isFinite","remapAst"],"mappings":"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"}