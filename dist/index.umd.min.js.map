{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["import * as seedrandom from 'seedrandom';\n\nexport type DictOf<T> = { [key: string]: T };\nexport type TExprScalar = number | string | boolean | null;\nexport type TExprFuncAsync = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExprScalar[]\n) => Promise<TExprScalar>;\nexport type TExprFuncSync = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExprScalar[]\n) => TExprScalar;\nexport type TExprFuncDef = {\n  assignment?: true;\n  lazy?: true;\n} & (\n  | {\n      async: true;\n      f: TExprFuncAsync;\n    }\n  | {\n      async?: false;\n      f: TExprFuncSync;\n    }\n);\n\nexport type TBinopDef = {\n  alias: string;\n};\nexport type TUnopDef = {\n  alias: string;\n};\n\nexport type TExprResult = {\n  result: TExprScalar;\n  ctx: TExprContext;\n};\n\nexport type TExprContext = {\n  rng: () => number;\n  funcs: DictOf<TExprFuncDef>;\n  binops: DictOf<TBinopDef>;\n  unops: DictOf<TUnopDef>;\n  get: (scope: TScope, key: string) => Promise<TExprScalar>;\n  set: (scope: TScope, key: string, value: TExprScalar) => Promise<void>;\n  call?:\n    | ((\n        ctx: TExprContext,\n        scope: TScope,\n        method: string,\n        args: TExprScalar[],\n      ) => Promise<TExprScalar>)\n    | undefined;\n};\n\nexport type TScope = { [key: string]: TExprScalar };\n\nexport type TExpression =\n  | TCallExpression\n  | TIdentifierExpression\n  | TBinaryExpression\n  | TLiteralExpression\n  | TTernaryExpression\n  | TUnaryExpression\n  | TTemplateLiteralExpression;\n\nexport type TTemplateLiteralExpression = {\n  type: 'TemplateLiteral';\n  parts: [['chunks', string] | ['expression', TExpression]];\n};\n\nexport type TCallExpression = {\n  type: 'CallExpression';\n  callee: TIdentifierExpression;\n  arguments: TExpression[];\n};\n\nexport type TIdentifierExpression = {\n  type: 'Identifier';\n  name: string;\n};\n\nexport type TBinaryExpression = {\n  type: 'BinaryExpression';\n  left: TExpression;\n  operator: string;\n  right: TExpression;\n};\n\nexport type TLiteralExpression = {\n  type: 'Literal';\n  value: string;\n  raw: string;\n};\n\nexport type TTernaryExpression = {\n  type: 'TernaryExpression';\n  test: TExpression;\n  consequent: TExpression;\n  alternate: TExpression;\n};\n\nexport type TUnaryExpression = {\n  type: 'UnaryExpression';\n  argument: TExpression;\n  operator: string;\n};\n\nexport const CONSTS: DictOf<TExprScalar> = {\n  E: Math.E,\n  LN10: Math.LN10,\n  LN2: Math.LN2,\n  LOG10E: Math.LOG10E,\n  LOG2E: Math.LOG2E,\n  PI: Math.PI,\n  SQRT1_2: Math.SQRT1_2,\n  SQRT2: Math.SQRT2,\n};\n\nconst BINOP_MAP = {\n  '**': { alias: 'pow' },\n  '*': { alias: 'mul' },\n  '/': { alias: 'div' },\n  '%': { alias: 'mod' },\n  '+': { alias: 'add' },\n  '-': { alias: 'sub' },\n  '>>>': { alias: 'bitwiseRightShiftUnsigned' },\n  '<<': { alias: 'bitwiseLeftShift' },\n  '>>': { alias: 'bitwiseRightShift' },\n  '<=': { alias: 'lte' },\n  '>=': { alias: 'gte' },\n  '<': { alias: 'lt' },\n  '>': { alias: 'gt' },\n  '===': { alias: 'eq' },\n  '!==': { alias: 'neq' },\n  '==': { alias: 'eq' },\n  '!=': { alias: 'neq' },\n  '&': { alias: 'bitwiseAnd' },\n  '^': { alias: 'bitwiseXor' },\n  '|': { alias: 'bitwiseOr' },\n  '&&': { alias: 'and' },\n  '||': { alias: 'or' },\n  ':=': { alias: 'setVar' },\n  '+=': { alias: 'setAdd' },\n  '-=': { alias: 'setSub' },\n  '/=': { alias: 'setDiv' },\n  '*=': { alias: 'setMul' },\n  '??': { alias: 'nullCoalesce' },\n};\n\nconst UNOP_MAP = {\n  '+': { alias: 'number' },\n  '-': { alias: 'negate' },\n  '~': { alias: 'bitwiseNot' },\n  '!': { alias: 'not' },\n};\n\nconst IgnoreWhitespace = (Rule) => Ignore(/^\\s+/, Rule);\nconst QuoteToken = Any(\n  /^('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')/,\n  /^(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")/,\n);\nconst NumericToken = Any(\n  /^((?:[0-9]+\\.?[0-9]*|\\.[0-9]+)(?:[eE][-+]?[0-9]+)?)\\b/,\n  /^(0[xX][0-9a-fA-F]+)\\b/,\n);\nconst NullToken = /^(null)\\b/;\nconst BooleanToken = /^(true|false)\\b/;\nconst IdentifierToken = /^([a-zA-Z_$][a-zA-Z0-9_$.]*)/;\nconst InterpolationChunkToken = /^((?:\\$(?!{)|\\\\.|[^`$\\\\])+)/;\nconst BinaryOperatorPrecedence = [\n  '**',\n  Any('*', '/', '%'),\n  Any('+', '-'),\n  Any('>>>', '<<', '>>'),\n  Any('<=', '>=', '<', '>'),\n  Any('===', '!==', '==', '!='),\n  /^&(?!&)/,\n  '^',\n  /^\\|(?!\\|)/,\n  '&&',\n  '||',\n  '??',\n  Any(':=', '+=', '-=', '*=', '/='),\n];\n\nconst INVALID_IDENT_REGEX = /^__proto__|prototype|constructor$/;\n\nexport function createExprContext({\n  funcs,\n  binops,\n  unops,\n  seed = 'expreval',\n  get,\n  set,\n  call,\n}: Partial<TExprContext> & { seed?: string }): TExprContext {\n  const vars: { [key: string]: TExprScalar } = {};\n  return {\n    rng: seedrandom.default(seed),\n    funcs: { ...STDLIB, ...funcs },\n    binops: { ...BINOP_MAP, ...binops },\n    unops: { ...UNOP_MAP, ...unops },\n    get: async (scope, name) => {\n      if (name.match(INVALID_IDENT_REGEX)) {\n        return 0;\n      }\n      if (get) {\n        return (await get(scope, name)) ?? null;\n      }\n      return vars[name] ?? null;\n    },\n    set: async (scope, name, value) => {\n      if (name.match(INVALID_IDENT_REGEX)) {\n        return;\n      }\n      if (set) {\n        return await set(scope, name, value);\n      }\n      vars[name] = value;\n      return;\n    },\n    call,\n  };\n}\n\nexport async function evaluateExpr(\n  code: string,\n  ctx: TExprContext = createExprContext({}),\n  scope: TScope = {},\n): Promise<TExprResult> {\n  return {\n    result: await executeAst(parseExpr(code), ctx, scope),\n    ctx,\n  };\n}\n\nexport default evaluateExpr;\n\nexport function parseExpr(code: string): TExpression {\n  const parser = Parser(DefaultGrammar);\n  return parser(code.replace(/\\/\\/.*\\n/g, ''));\n}\n\nexport async function executeAst(\n  ast: TExpression,\n  ctx: TExprContext = createExprContext({}),\n  scope: TScope,\n): Promise<TExprScalar> {\n  switch (ast.type) {\n    case 'Literal':\n      return ast.value;\n    case 'Identifier':\n      const value = await ctx.get(scope, ast.name);\n      return value !== undefined ? value : ast.name;\n    case 'CallExpression':\n      const fdef = Object.keys(ctx.funcs).includes(ast.callee.name)\n        ? ctx.funcs[ast.callee.name]\n        : null;\n      const args: TExprScalar[] = [];\n      if (fdef && fdef.assignment && ast.arguments.length > 1) {\n        const left = exprToIdentifier(ast.arguments[0]!) ?? '';\n        const right = ast.arguments.slice(1);\n        args.push(\n          left,\n          ...(await asyncMap(\n            right,\n            async (expr) => await executeAst(expr, ctx, scope),\n          )),\n        );\n      } else {\n        args.push(\n          ...(await asyncMap(\n            ast.arguments,\n            async (expr) => await executeAst(expr, ctx, scope),\n          )),\n        );\n      }\n      if (fdef) {\n        if (fdef.async) {\n          return await fdef.f(ctx, scope, ...args);\n        }\n        return fdef.f(ctx, scope, ...args);\n      } else if (ctx.call) {\n        return await ctx.call(ctx, scope, ast.callee.name, args);\n      }\n      throw new Error(`Function not found: '${ast.callee.name}'`);\n    case 'BinaryExpression':\n      const binop = Object.keys(ctx.binops).includes(ast.operator)\n        ? ctx.binops[ast.operator]\n        : null;\n      if (binop) {\n        return executeAst(\n          {\n            type: 'CallExpression',\n            callee: {\n              name: binop.alias,\n              type: 'Identifier',\n            },\n            arguments: [ast.left, ast.right],\n          },\n          ctx,\n          scope,\n        );\n      }\n      throw new Error(`Operator not found: '${ast.operator}'`);\n    case 'TernaryExpression':\n      const result = await executeAst(ast.test, ctx, scope);\n      if (toBoolean(result)) {\n        return await executeAst(ast.consequent, ctx, scope);\n      }\n      return await executeAst(ast.alternate, ctx, scope);\n    case 'UnaryExpression':\n      const unop = Object.keys(ctx.unops).includes(ast.operator)\n        ? ctx.unops[ast.operator]\n        : null;\n      if (unop) {\n        return executeAst(\n          {\n            type: 'CallExpression',\n            callee: {\n              name: unop.alias,\n              type: 'Identifier',\n            },\n            arguments: [ast.argument],\n          },\n          ctx,\n          scope,\n        );\n      }\n      throw new Error(`Operator not found: '${ast.operator}'`);\n    case 'TemplateLiteral':\n      let accum = '';\n      for (let i = 0; i < ast.parts.length; i++) {\n        const [kind, value] = ast.parts[i]!;\n        if (kind === 'chunks') {\n          accum += value;\n        } else if (kind === 'expression') {\n          accum += (await executeAst(value, ctx, scope)) + '';\n        }\n      }\n      return accum;\n    default:\n      throw new Error(`Syntax error`);\n  }\n}\n\nexport function exprToIdentifier(v: TExpression): string | null {\n  if (v.type === 'Identifier') {\n    return v.name;\n  }\n  return null;\n}\n\nexport function toNumber(v: any, fallback: number = 0): number {\n  if (typeof v === 'number') {\n    return isNaN(v) ? fallback : v;\n  }\n  if (typeof v === 'string') {\n    if (v.includes('.')) {\n      return parseFloat(v);\n    }\n    return parseInt(v);\n  }\n  return fallback;\n}\n\nexport function toBoolean(v: TExprScalar): boolean {\n  if (!v) {\n    return false;\n  }\n  if (typeof v === 'string' && v.match(/^\\s+$/)) {\n    return false;\n  }\n  if (v === 'false') {\n    return false;\n  }\n  if (v === '0') {\n    return false;\n  }\n  return true;\n}\n\nexport function toString(v: TExprScalar, radix: number = 10): string {\n  if (typeof v === 'number') {\n    return v.toString(radix);\n  }\n  if (v === true || v === 'true') {\n    return 'true';\n  }\n  if (!v || v === 'false') {\n    return 'false';\n  }\n  return v + '';\n}\n\nexport function toScalar(n: any, radix: number = 10): TExprScalar {\n  if (typeof n === 'number') {\n    return n.toString(radix);\n  }\n  if (typeof n === 'string') {\n    return n;\n  }\n  if (typeof n === 'boolean') {\n    return n;\n  }\n  if (!n) {\n    return null;\n  }\n  return n + '';\n}\n\nasync function asyncMap<V, T>(\n  array: V[],\n  callback: (el: V, idx: number, arr: V[]) => Promise<T>,\n) {\n  const out: T[] = [];\n  for (let index = 0; index < array.length; index++) {\n    const m = await callback(array[index]!, index, array);\n    out.push(m);\n  }\n  return out;\n}\n\nasync function setVar<T extends TExprScalar>(\n  ctx: TExprContext,\n  scope: TScope,\n  name: any,\n  value: T,\n): Promise<T> {\n  const key = toString(name);\n  await ctx.set(scope, key, value);\n  return value;\n}\n\nasync function getVar(\n  ctx: TExprContext,\n  scope: TScope,\n  name: any,\n): Promise<TExprScalar> {\n  return (await ctx.get(scope, name + '')) ?? null;\n}\n\nexport const STDLIB: DictOf<TExprFuncDef> = {\n  do: {\n    f(ctx, scope, ...args) {\n      return args[args.length - 1] ?? null;\n    },\n  },\n\n  present: {\n    f(ctx, scope, v) {\n      return !!v;\n    },\n  },\n  empty: {\n    f(ctx, scope, v) {\n      return !v;\n    },\n  },\n  blank: {\n    f(ctx, scope, v) {\n      if (typeof v === 'string' && (!v || v.match(/^\\s+$/))) {\n        return true;\n      }\n      return !v;\n    },\n  },\n\n  join: {\n    f(ctx, scope, spacer, ...ss) {\n      return ss.join(toString(spacer));\n    },\n  },\n\n  setVar: {\n    assignment: true,\n    async: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(ctx, scope, left, right);\n    },\n  },\n  setAdd: {\n    assignment: true,\n    async: true,\n    async f(ctx, scope, left, right) {\n      const lval = await getVar(ctx, scope, left);\n      if (typeof lval === 'string') {\n        return await setVar(ctx, scope, left, lval + right + '');\n      }\n      return await setVar(ctx, scope, left, toNumber(lval) + toNumber(right));\n    },\n  },\n  setSub: {\n    assignment: true,\n    async: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(await getVar(ctx, scope, left)) - toNumber(right),\n      );\n    },\n  },\n  setMul: {\n    assignment: true,\n    async: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(await getVar(ctx, scope, left)) * toNumber(right),\n      );\n    },\n  },\n  setDiv: {\n    assignment: true,\n    async: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(await getVar(ctx, scope, left)) / toNumber(right),\n      );\n    },\n  },\n\n  nullCoalesce: {\n    f(ctx, scope, a, b) {\n      return a ?? b;\n    },\n  },\n\n  unixTimestampNow: {\n    f() {\n      return Date.now();\n    },\n  },\n  unixTimestampForDate: {\n    f(ctx, scope, year, mon, day, hour, min, second) {\n      return new Date(\n        toNumber(year),\n        toNumber(mon),\n        toNumber(day),\n        toNumber(hour),\n        toNumber(min),\n        toNumber(second),\n      ).getTime();\n    },\n  },\n\n  all: {\n    f(ctx, scope, ...xs) {\n      for (let i = 0; i < xs.length; i++) {\n        if (!xs[i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n  },\n  any: {\n    f(ctx, scope, ...xs) {\n      for (let i = 0; i < xs.length; i++) {\n        if (xs[i]) {\n          return true;\n        }\n      }\n      return false;\n    },\n  },\n  some: {\n    f(ctx, scope, ...xs) {\n      return !!STDLIB['any']!.f(ctx, scope, ...xs);\n    },\n  },\n  none: {\n    f(ctx, scope, ...xs) {\n      return !STDLIB['any']!.f(ctx, scope, ...xs);\n    },\n  },\n\n  or: {\n    f(ctx, scope, a, b) {\n      return toBoolean(a) || toBoolean(b);\n    },\n  },\n  and: {\n    f(ctx, scope, a, b) {\n      return toBoolean(a) && toBoolean(b);\n    },\n  },\n  not: {\n    f(ctx, scope, a) {\n      return !toBoolean(a);\n    },\n  },\n\n  gt: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  gte: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  lt: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  lte: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  eq: {\n    f(ctx, scope, a, b) {\n      return toString(a) === toString(b);\n    },\n  },\n  neq: {\n    f(ctx, scope, a, b) {\n      return toString(a) !== toString(b);\n    },\n  },\n\n  rand: {\n    f(ctx) {\n      return ctx.rng();\n    },\n  },\n  randInRange: {\n    f(ctx, scope, min, max) {\n      return ctx.rng() * (Number(max) - Number(min)) + Number(min);\n    },\n  },\n  randInt: {\n    f(ctx) {\n      return Math.floor(ctx.rng() * 10);\n    },\n  },\n  randIntInRange: {\n    f(ctx, scope, min, max) {\n      min = Math.ceil(Number(min));\n      max = Math.floor(Number(max));\n      return Math.floor(ctx.rng() * (max - min + 1)) + min;\n    },\n  },\n\n  number: {\n    f(ctx, scope, a) {\n      return Number(a);\n    },\n  },\n  bitwiseOr: {\n    f(ctx, scope, a, b) {\n      return Number(a) | Number(b);\n    },\n  },\n  bitwiseXor: {\n    f(ctx, scope, a, b) {\n      return Number(a) ^ Number(b);\n    },\n  },\n  bitwiseAnd: {\n    f(ctx, scope, a, b) {\n      return Number(a) & Number(b);\n    },\n  },\n  bitwiseNot: {\n    f(ctx, scope, a) {\n      return ~Number(a);\n    },\n  },\n  bitwiseLeftShift: {\n    f(ctx, scope, a, b) {\n      return Number(a) << Number(b);\n    },\n  },\n  bitwiseRightShift: {\n    f(ctx, scope, a, b) {\n      return Number(a) >> Number(b);\n    },\n  },\n  bitwiseRightshiftUnsigned: {\n    f(ctx, scope, a, b) {\n      return Number(a) >>> Number(b);\n    },\n  },\n  negate: {\n    f(ctx, scope, a) {\n      return -toNumber(a);\n    },\n  },\n  add: {\n    f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a + b + '';\n      }\n      return toNumber(a) + toNumber(b);\n    },\n  },\n  sub: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) - toNumber(b);\n    },\n  },\n  div: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) / toNumber(b);\n    },\n  },\n  mul: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) * toNumber(b);\n    },\n  },\n  mod: {\n    f(ctx, scope, a, b) {\n      return toNumber(a) % toNumber(b);\n    },\n  },\n  pow: {\n    f(ctx, scope, a, b) {\n      return Math.pow(toNumber(a), toNumber(b));\n    },\n  },\n\n  abs: {\n    f(ctx, scope, a) {\n      return Math.abs(toNumber(a));\n    },\n  },\n  acos: {\n    f(ctx, scope, a) {\n      return Math.acos(toNumber(a));\n    },\n  },\n  acosh: {\n    f(ctx, scope, a) {\n      return Math.acosh(toNumber(a));\n    },\n  },\n  asin: {\n    f(ctx, scope, a) {\n      return Math.asin(toNumber(a));\n    },\n  },\n  asinh: {\n    f(ctx, scope, a) {\n      return Math.asinh(toNumber(a));\n    },\n  },\n  atan: {\n    f(ctx, scope, a) {\n      return Math.atan(toNumber(a));\n    },\n  },\n  atan2: {\n    f(ctx, scope, a, b) {\n      return Math.atan2(toNumber(a), toNumber(b));\n    },\n  },\n  atanh: {\n    f(ctx, scope, a) {\n      return Math.atanh(toNumber(a));\n    },\n  },\n  cbrt: {\n    f(ctx, scope, a) {\n      return Math.cbrt(toNumber(a));\n    },\n  },\n  ceil: {\n    f(ctx, scope, a) {\n      return Math.ceil(toNumber(a));\n    },\n  },\n  cos: {\n    f(ctx, scope, a) {\n      return Math.cos(toNumber(a));\n    },\n  },\n  cosh: {\n    f(ctx, scope, a) {\n      return Math.cosh(toNumber(a));\n    },\n  },\n  exp: {\n    f(ctx, scope, a) {\n      return Math.exp(toNumber(a));\n    },\n  },\n  floor: {\n    f(ctx, scope, a) {\n      return Math.floor(toNumber(a));\n    },\n  },\n  hypot: {\n    f(ctx, scope, a) {\n      return Math.hypot(toNumber(a));\n    },\n  },\n  log: {\n    f(ctx, scope, a) {\n      return Math.log(toNumber(a));\n    },\n  },\n  log10: {\n    f(ctx, scope, a) {\n      return Math.log10(toNumber(a));\n    },\n  },\n  log2: {\n    f(ctx, scope, a) {\n      return Math.log2(toNumber(a));\n    },\n  },\n  max: {\n    f(ctx, scope, a) {\n      return Math.max(toNumber(a));\n    },\n  },\n  min: {\n    f(ctx, scope, a) {\n      return Math.min(toNumber(a));\n    },\n  },\n  round: {\n    f(ctx, scope, a) {\n      return Math.round(toNumber(a));\n    },\n  },\n  sign: {\n    f(ctx, scope, a) {\n      return Math.sign(toNumber(a));\n    },\n  },\n  sin: {\n    f(ctx, scope, a) {\n      return Math.sin(toNumber(a));\n    },\n  },\n  sinh: {\n    f(ctx, scope, a) {\n      return Math.sinh(toNumber(a));\n    },\n  },\n  sqrt: {\n    f(ctx, scope, a) {\n      return Math.sqrt(toNumber(a));\n    },\n  },\n  tan: {\n    f(ctx, scope, a) {\n      return Math.tan(toNumber(a));\n    },\n  },\n  tanh: {\n    f(ctx, scope, a) {\n      return Math.tanh(toNumber(a));\n    },\n  },\n  trunc: {\n    f(ctx, scope, a) {\n      return Math.trunc(toNumber(a));\n    },\n  },\n\n  fromCharCode: {\n    f(ctx, scope, a) {\n      return String.fromCharCode(Number(a));\n    },\n  },\n  fromCodePoint: {\n    f(ctx, scope, a) {\n      return String.fromCodePoint(Number(a));\n    },\n  },\n  parseInt: {\n    f(ctx, scope, a, b) {\n      return parseInt(toString(a), Number(b));\n    },\n  },\n  parseFloat: {\n    f(ctx, scope, a) {\n      return parseFloat(toString(a));\n    },\n  },\n  length: {\n    f(ctx, scope, a) {\n      return toString(a).length;\n    },\n  },\n  charAt: {\n    f(ctx, scope, a, b) {\n      return toString(a).charAt(Number(b));\n    },\n  },\n  charCodeAt: {\n    f(ctx, scope, a, b) {\n      return toString(a).charCodeAt(Number(b));\n    },\n  },\n  codePointAt: {\n    f(ctx, scope, a, b) {\n      return toString(a).codePointAt(Number(b)) ?? 0;\n    },\n  },\n  concat: {\n    f(ctx, scope, ...ss) {\n      return ''.concat(...ss.map((s) => toString(s)));\n    },\n  },\n  endsWith: {\n    f(ctx, scope, a, b) {\n      return toString(a).endsWith(toString(b));\n    },\n  },\n  includes: {\n    f(ctx, scope, a, b) {\n      return toString(a).includes(toString(b));\n    },\n  },\n  indexOf: {\n    f(ctx, scope, a, b) {\n      return toString(a).indexOf(toString(b));\n    },\n  },\n  lastIndexOf: {\n    f(ctx, scope, a, b) {\n      return toString(a).lastIndexOf(toString(b));\n    },\n  },\n  localeCompare: {\n    f(ctx, scope, a, b) {\n      return toString(a).localeCompare(toString(b));\n    },\n  },\n  match: {\n    f(ctx, scope, a, b) {\n      return !!toString(a).match(toString(b));\n    },\n  },\n  matchAll: {\n    f(ctx, scope, a, b) {\n      return !!toString(a).match(toString(b));\n    },\n  },\n  padEnd: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).padEnd(Number(b), toString(c ?? ''));\n    },\n  },\n  padStart: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).padStart(Number(b), toString(c ?? ''));\n    },\n  },\n  repeat: {\n    f(ctx, scope, a, b) {\n      return toString(a).repeat(Number(b));\n    },\n  },\n  replace: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).replace(toString(b), toString(c));\n    },\n  },\n  replaceAll: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).replaceAll(toString(b), toString(c));\n    },\n  },\n  slice: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).slice(Number(b), Number(c ?? toString(a).length));\n    },\n  },\n  startsWith: {\n    f(ctx, scope, a, b) {\n      return toString(a).startsWith(toString(b));\n    },\n  },\n  substring: {\n    f(ctx, scope, a, b, c) {\n      return toString(a).substring(Number(b), Number(c));\n    },\n  },\n  toLowerCase: {\n    f(ctx, scope, a) {\n      return toString(a).toLowerCase();\n    },\n  },\n  toUpperCase: {\n    f(ctx, scope, a) {\n      return toString(a).toUpperCase();\n    },\n  },\n  trim: {\n    f(ctx, scope, a) {\n      return toString(a).trim();\n    },\n  },\n  trimEnd: {\n    f(ctx, scope, a) {\n      return toString(a).trimEnd();\n    },\n  },\n  trimStart: {\n    f(ctx, scope, a) {\n      return toString(a).trimStart();\n    },\n  },\n\n  avg: {\n    f(ctx, ...nn) {\n      return avg(nn.map((n) => toNumber(n)));\n    },\n  },\n  sum: {\n    f(ctx, ...nn) {\n      return sum(nn.map((n) => toNumber(n)));\n    },\n  },\n  clamp: {\n    f(ctx, a, min, max) {\n      return clamp(toNumber(a), toNumber(min), toNumber(max));\n    },\n  },\n};\n\n// The code below is derived from code at https://github.com/dmaevsky/rd-parse. License:\n// The MIT License (MIT)\n// Copyright 2013 - present Dmitry Maevsky\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst associativity = (binop) => (binop === '**' ? r2l : l2r);\n\nfunction locAt(text, newPos, { pos, line, column }) {\n  while (pos < newPos) {\n    const ch = text[pos++];\n    if (ch === '\\n') {\n      column = 1;\n      line++;\n    } else {\n      column++;\n    }\n  }\n  return { pos, line, column };\n}\n\nconst markSeen = ($) => {\n  if ($.pos > $.lastSeen.pos) {\n    Object.assign($.lastSeen, locAt($.text, $.pos, $.lastSeen));\n  }\n};\n\nfunction RegexToken(pattern) {\n  return ($) => {\n    markSeen($);\n    const match = pattern.exec($.text.substring($.pos));\n    if (!match) {\n      return $;\n    }\n    const $next = {\n      ...$,\n      pos: $.pos + match[0].length,\n    };\n    for (let i = 1; i < match.length; i++) {\n      $.stack[$next.sp++] = match[i];\n    }\n    return $next;\n  };\n}\n\nfunction StringToken(pattern) {\n  return ($) => {\n    markSeen($);\n    if ($.text.startsWith(pattern, $.pos)) {\n      return {\n        ...$,\n        pos: $.pos + pattern.length,\n      };\n    }\n    return $;\n  };\n}\n\nfunction Use(rule) {\n  if (typeof rule === 'function') {\n    return rule;\n  }\n  if (rule instanceof RegExp) {\n    return RegexToken(rule);\n  }\n  if (typeof rule === 'string') {\n    return StringToken(rule);\n  }\n  throw new Error('Invalid rule');\n}\n\nfunction Ignore(toIgnore, rule) {\n  rule = Use(rule);\n  if (toIgnore) {\n    toIgnore = Ignore(null, Plus(toIgnore));\n  }\n\n  return ($) => {\n    const $cur = toIgnore ? toIgnore($) : $;\n    $.ignore.push(toIgnore);\n    const $next = rule($cur);\n    $.ignore.pop();\n    return $next === $cur ? $ : toIgnore ? toIgnore($next) : $next;\n  };\n}\n\nconst skipIgnored = ($) => {\n  if (!$.ignore.length) {\n    return $;\n  }\n  const toIgnore = $.ignore[$.ignore.length - 1];\n  return toIgnore ? toIgnore($) : $;\n};\n\nfunction All(...rules) {\n  rules = rules.map(Use);\n  return ($) => {\n    let $cur = $;\n    for (let i = 0; i < rules.length; i++) {\n      const $before = i > 0 ? skipIgnored($cur) : $cur;\n      const $after = rules[i]($before);\n      if ($after === $before) {\n        return $;\n      }\n      if ($after.pos > $before.pos || $after.sp > $before.sp) {\n        $cur = $after;\n      }\n    }\n    return $cur;\n  };\n}\n\nfunction Any(...rules) {\n  rules = rules.map(Use);\n  return ($) => {\n    for (let i = 0; i < rules.length; i++) {\n      const $next = rules[i]($);\n      if ($next !== $) {\n        return $next;\n      }\n    }\n    return $;\n  };\n}\n\nfunction Plus(rule) {\n  rule = Use(rule);\n  return ($) => {\n    while (true) {\n      const $cur = skipIgnored($);\n      const $next = rule($cur);\n      if ($next === $cur) {\n        return $;\n      }\n      $ = $next;\n    }\n  };\n}\n\nfunction Optional(rule) {\n  rule = Use(rule);\n  return ($) => {\n    const $next = rule($);\n    if ($next !== $) {\n      return $next;\n    }\n    return { ...$ };\n  };\n}\n\nfunction Node(rule, reducer) {\n  rule = Use(rule);\n  return ($) => {\n    const $next = rule($);\n    if ($next === $) {\n      return $;\n    }\n    const node = reducer($.stack.slice($.sp, $next.sp), $, $next);\n    $next.sp = $.sp;\n    if (node !== null) {\n      $.stack[$next.sp++] = node;\n    }\n    return $next;\n  };\n}\n\nconst Star = (rule) => Optional(Plus(rule));\n\nconst Y = (proc) => ((x) => proc((y) => x(x)(y)))((x) => proc((y) => x(x)(y)));\n\nconst START = (text, pos = 0) => ({\n  text,\n  ignore: [],\n  stack: [],\n  sp: 0,\n  lastSeen: locAt(text, pos, { pos: 0, line: 1, column: 1 }),\n  pos,\n});\n\nfunction Parser(\n  Grammar,\n  pos = 0,\n  partial = false,\n): (text: string) => TExpression {\n  return (text) => {\n    if (typeof text !== 'string') {\n      throw new Error('Parsing function expects a string input');\n    }\n    const $ = START(text, pos);\n    const $next = Grammar($);\n    if ($ === $next || (!partial && $next.pos < text.length)) {\n      throw new Error(\n        `Unexpected token at ${$.lastSeen.line}:${\n          $.lastSeen.column\n        }. Remainder: ${text.slice($.lastSeen.pos)}`,\n      );\n    }\n    return $.stack[0] as unknown as TExpression;\n  };\n}\n\nfunction l2r(parts, $) {\n  let left = parts[0];\n  for (let i = 1; i < parts.length; i += 2) {\n    const [operator, right] = [parts[i].operator, parts[i + 1]];\n    left = srcMap(\n      {\n        type: 'BinaryExpression',\n        left,\n        operator,\n        right,\n      },\n      $,\n      { pos: right.pos + right.text.length },\n    );\n  }\n  return left;\n}\n\nfunction r2l(parts, _, $next) {\n  let right = parts[parts.length - 1];\n  for (let i = parts.length - 2; i >= 0; i -= 2) {\n    const [left, operator] = [parts[i - 1], parts[i].operator];\n    right = srcMap(\n      {\n        type: 'BinaryExpression',\n        left,\n        operator,\n        right,\n      },\n      { pos: left.pos },\n      $next,\n    );\n  }\n  return right;\n}\n\nconst Operator = (Rule) =>\n  Node(Rule, (_, $, $next) => ({\n    $,\n    operator: $.text.substring($.pos, $next.pos),\n  }));\n\nconst srcMap = (obj, $, $next) =>\n  Object.defineProperties(obj, {\n    pos: { writable: true, configurable: true, value: $.pos },\n    text: {\n      writable: true,\n      configurable: true,\n      value: ($.text || $next.text).slice($.pos, $next.pos),\n    },\n  });\n\nconst DefaultGrammar = IgnoreWhitespace(\n  Y((Expression) => {\n    const Identifier = Node(IdentifierToken, ([name]) => ({\n      type: 'Identifier',\n      name,\n    }));\n    const StringLiteral = Node(QuoteToken, ([raw]) => ({\n      type: 'Literal',\n      value: raw.slice(1, -1),\n      raw,\n    }));\n    const NumericLiteral = Node(NumericToken, ([raw]) => ({\n      type: 'Literal',\n      value: +raw,\n      raw,\n    }));\n    const NullLiteral = Node(NullToken, ([raw]) => ({\n      type: 'Literal',\n      value: null,\n      raw,\n    }));\n    const BooleanLiteral = Node(BooleanToken, ([raw]) => ({\n      type: 'Literal',\n      value: raw === 'true',\n      raw,\n    }));\n    const InterpolationChunk = Node(InterpolationChunkToken, ([raw]) => [\n      'chunks',\n      raw,\n    ]);\n    const TemplateInlineExpression = Node(\n      All('${', IgnoreWhitespace(Expression), '}'),\n      ([expression]) => ['expression', expression],\n    );\n    const TemplateLiteral = Node(\n      Ignore(\n        null,\n        All('`', Star(Any(InterpolationChunk, TemplateInlineExpression)), '`'),\n      ),\n      (parts) => ({ type: 'TemplateLiteral', parts }),\n    );\n    const Literal = Any(\n      StringLiteral,\n      NumericLiteral,\n      NullLiteral,\n      BooleanLiteral,\n      TemplateLiteral,\n    );\n    const ArgumentsList = All(Expression, Star(All(',', Expression)));\n    const Arguments = Node(\n      All('(', Optional(All(ArgumentsList, Optional(','))), ')'),\n      (args) => ({\n        args,\n      }),\n    );\n    const ArgumentsExpression = Node(Any(Arguments), ([part], _, $next) => ({\n      part,\n      $next,\n    }));\n    const CompoundExpression = Node(\n      All(Expression, Star(All(',', Expression))),\n      (leafs) =>\n        leafs.length > 1 ? { type: 'CompoundExpression', leafs } : leafs[0],\n    );\n    const PrimaryExpression = Node(\n      Any(Literal, Identifier, All('(', CompoundExpression, ')')),\n      ([expr], $, $next) => srcMap(expr, $, $next),\n    );\n    const CallExpression = Node(\n      All(PrimaryExpression, Star(ArgumentsExpression)),\n      (parts, $, $last) => {\n        return parts.reduce((acc, { part, $next }) => {\n          return srcMap(\n            { type: 'CallExpression', callee: acc, arguments: part.args },\n            $,\n            $next,\n          );\n        });\n      },\n    );\n    const UnaryOperator = Operator(Any('+', '-', '~', '!'));\n    const UnaryExpression = Node(\n      All(Star(UnaryOperator), CallExpression),\n      (parts, _, $next) =>\n        parts.reduceRight((argument, { $, operator }) =>\n          srcMap({ type: 'UnaryExpression', argument, operator }, $, $next),\n        ),\n    );\n    const LogicalExpressionOrExpression = BinaryOperatorPrecedence.reduce(\n      (Expr, BinaryOp) =>\n        Node(\n          All(Expr, Star(All(Operator(BinaryOp), Expr))),\n          associativity(BinaryOp),\n        ),\n      UnaryExpression,\n    );\n    const TernaryExpression = Node(\n      All(\n        LogicalExpressionOrExpression,\n        Optional(All('?', Expression, ':', Expression)),\n      ),\n      ([test, consequent, alternate]) =>\n        consequent\n          ? { type: 'TernaryExpression', test, consequent, alternate }\n          : test,\n    );\n    return Node(Any(TernaryExpression), ([expr], $, $next) =>\n      srcMap(expr, $, $next),\n    );\n  }),\n);\n\nexport function clamp(n: number, min: number = 0, max: number = 1): number {\n  if (n < min) return min;\n  if (n > max) return max;\n  return n;\n}\nexport function avg(nn: number[]): number {\n  if (nn.length < 1) return 0;\n  return sum(nn) / nn.length;\n}\nexport function sum(nn: number[]): number {\n  let n = 0;\n  for (let i = 0; i < nn.length; i++) n += nn[i]!;\n  return n;\n}\n"],"names":["CONSTS","E","Math","LN10","LN2","LOG10E","LOG2E","PI","SQRT1_2","SQRT2","BINOP_MAP","alias","UNOP_MAP","IgnoreWhitespace","Rule","Ignore","QuoteToken","Any","NumericToken","NullToken","BooleanToken","IdentifierToken","InterpolationChunkToken","BinaryOperatorPrecedence","INVALID_IDENT_REGEX","createExprContext","_a","_this","this","funcs","binops","unops","_b","seed","get","set","call","vars","rng","seedrandom","default","__assign","STDLIB","scope","name","__awaiter","match","_c","sent","value","evaluateExpr","code","ctx","executeAst","parseExpr","result","Grammar","pos","partial","text","Error","$","ignore","stack","sp","lastSeen","locAt","line","column","START","$next","length","concat","slice","Parser","DefaultGrammar","parser","replace","ast","type","undefined","_m","fdef","Object","keys","includes","callee","args","assignment","arguments","left","exprToIdentifier","right","_d","push","apply","asyncMap","expr","__generator","_e","__spreadArray","_f","_h","_g","_j","async","f","binop","operator","test","toBoolean","consequent","alternate","unop","argument","accum","i","parts","_k","kind","value_1","_l","v","toNumber","fallback","isNaN","parseFloat","parseInt","toString","radix","array","callback","out","index","m","setVar","key","getVar","do","_i","present","empty","blank","join","spacer","ss","setAdd","lval","setSub","setMul","setDiv","nullCoalesce","a","b","unixTimestampNow","Date","now","unixTimestampForDate","year","mon","day","hour","min","second","getTime","all","xs","any","some","none","or","and","not","gt","gte","lt","lte","eq","neq","rand","randInRange","max","Number","randInt","floor","randIntInRange","ceil","number","bitwiseOr","bitwiseXor","bitwiseAnd","bitwiseNot","bitwiseLeftShift","bitwiseRightShift","bitwiseRightshiftUnsigned","negate","add","sub","div","mul","mod","pow","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","cos","cosh","exp","hypot","log","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc","fromCharCode","String","fromCodePoint","charAt","charCodeAt","codePointAt","map","s","endsWith","indexOf","lastIndexOf","localeCompare","matchAll","padEnd","c","padStart","repeat","replaceAll","startsWith","substring","toLowerCase","toUpperCase","trim","trimEnd","trimStart","avg","nn","n","sum","clamp","newPos","markSeen","assign","Use","rule","RegExp","pattern","exec","StringToken","toIgnore","Plus","$cur","pop","skipIgnored","All","rules","$before","$after","Optional","Node","reducer","node","Star","l2r","srcMap","r2l","_","proc","x","Operator","obj","defineProperties","writable","configurable","y","Expression","Identifier","StringLiteral","raw","NumericLiteral","NullLiteral","BooleanLiteral","InterpolationChunk","TemplateInlineExpression","TemplateLiteral","Literal","ArgumentsList","Arguments","ArgumentsExpression","part","CompoundExpression","leafs","PrimaryExpression","CallExpression","$last","reduce","acc","UnaryOperator","UnaryExpression","reduceRight","LogicalExpressionOrExpression","Expr","BinaryOp","TernaryExpression"],"mappings":"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"}