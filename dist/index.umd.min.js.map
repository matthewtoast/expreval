{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["import * as seedrandom from 'seedrandom';\nimport { z } from 'zod';\n\nexport type DictOf<T> = { [key: string]: T };\n\nexport const ZExprScalar = z.union([\n  z.number(),\n  z.string(),\n  z.boolean(),\n  z.null(),\n]);\nexport type TExprScalar = number | string | boolean | null;\nexport type TExprArray = TExprValue[];\nexport type TExprObject = { [key: string]: TExprValue };\nexport type TExprValue = TExprScalar | TExprObject | TExprArray;\n\nexport type TExprFuncSync = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExprValue[]\n) => TExprValue;\nexport type TExprFuncAsync = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExprValue[]\n) => Promise<TExprValue>;\nexport type TExprFuncLazy = (\n  ctx: TExprContext,\n  scope: TScope,\n  ...args: TExpression[]\n) => TExprValue;\nexport type TExprFuncDef =\n  | {\n      assignment?: true;\n      lazy?: undefined;\n      f: TExprFuncAsync;\n    }\n  | {\n      lazy: true;\n      f: TExprFuncLazy;\n    };\n\nexport type TBinopDef = {\n  alias: string;\n};\nexport type TUnopDef = {\n  alias: string;\n};\n\nexport type TExprResult = {\n  result: TExprValue;\n  ctx: TExprContext;\n};\n\nexport type TExprContext = {\n  rng: () => number;\n  funcs: DictOf<TExprFuncDef>;\n  binops: DictOf<TBinopDef>;\n  unops: DictOf<TUnopDef>;\n  get: (scope: TScope, key: string) => Promise<TExprValue>;\n  set: (scope: TScope, key: string, value: TExprValue) => Promise<void>;\n  call?:\n    | ((\n        ctx: TExprContext,\n        scope: TScope,\n        method: string,\n        args: TExprValue[],\n      ) => Promise<TExprValue>)\n    | undefined;\n  lazy?:\n    | ((\n        ctx: TExprContext,\n        scope: TScope,\n        method: string,\n        args: TExpression[],\n      ) => Promise<TExprValue>)\n    | undefined;\n};\n\nexport type TScope = { [key: string]: TExprValue };\n\nexport type TExpression =\n  | TCallExpression\n  | TIdentifierExpression\n  | TBinaryExpression\n  | TLiteralExpression\n  | TConditionalExpression\n  | TUnaryExpression\n  | TTemplateLiteralExpression\n  | TArrayLiteralExpression\n  | TObjectLiteralExpression\n  | TComputedPropertyExpression\n  | TArrowFunctionExpression;\n\nexport type TTemplateLiteralPart =\n  | ['chunks', string]\n  | ['expression', TExpression];\n\nexport type TTemplateLiteralExpression = {\n  type: 'TemplateLiteral';\n  parts: TTemplateLiteralPart[];\n};\n\nexport type TComputedPropertyExpression = {\n  type: 'ComputedProperty';\n  expression: TExpression;\n};\n\nexport type TArrayLiteralExpression = {\n  type: 'ArrayLiteral';\n  elements: TExpression[];\n};\n\nexport type TObjectLiteralExpression = {\n  type: 'ObjectLiteral';\n  properties: {\n    name: TExpression;\n    value: TExpression | undefined;\n  }[];\n};\n\nexport type TCallExpression = {\n  type: 'CallExpression';\n  callee: TIdentifierExpression;\n  arguments: TExpression[];\n};\n\nexport type TIdentifierExpression = {\n  type: 'Identifier';\n  name: string;\n};\n\nexport type TBinaryExpression = {\n  type: 'BinaryExpression';\n  left: TExpression;\n  operator: string;\n  right: TExpression;\n};\n\nexport type TLiteralExpression = {\n  type: 'Literal';\n  value: string;\n  raw: string;\n};\n\nexport type TConditionalExpression = {\n  type: 'ConditionalExpression';\n  test: TExpression;\n  consequent: TExpression;\n  alternate: TExpression;\n};\n\nexport type TUnaryExpression = {\n  type: 'UnaryExpression';\n  argument: TExpression;\n  operator: string;\n};\n\nexport type TArrowFunctionExpression = {\n  type: 'ArrowFunction';\n  parameters: { type: 'BoundName'; name: string }[];\n  result: TExpression;\n};\n\nexport const CONSTS: DictOf<TExprValue> = {\n  E: Math.E,\n  LN10: Math.LN10,\n  LN2: Math.LN2,\n  LOG10E: Math.LOG10E,\n  LOG2E: Math.LOG2E,\n  PI: Math.PI,\n  SQRT1_2: Math.SQRT1_2,\n  SQRT2: Math.SQRT2,\n};\n\nconst BINOP_MAP = {\n  '**': { alias: 'pow' },\n  '*': { alias: 'mul' },\n  '/': { alias: 'div' },\n  '%': { alias: 'mod' },\n  '+': { alias: 'add' },\n  '-': { alias: 'sub' },\n  '>>>': { alias: 'bitwiseRightShiftUnsigned' },\n  '<<': { alias: 'bitwiseLeftShift' },\n  '>>': { alias: 'bitwiseRightShift' },\n  '<=': { alias: 'lte' },\n  '>=': { alias: 'gte' },\n  '<': { alias: 'lt' },\n  '>': { alias: 'gt' },\n  '===': { alias: 'eq' },\n  '!==': { alias: 'neq' },\n  '==': { alias: 'eq' },\n  '!=': { alias: 'neq' },\n  '&': { alias: 'bitwiseAnd' },\n  '^': { alias: 'bitwiseXor' },\n  '|': { alias: 'bitwiseOr' },\n  '&&': { alias: 'and' },\n  '||': { alias: 'or' },\n  ':=': { alias: 'setVar' },\n  '+=': { alias: 'setAdd' },\n  '-=': { alias: 'setSub' },\n  '/=': { alias: 'setDiv' },\n  '*=': { alias: 'setMul' },\n  '??': { alias: 'nullCoalesce' },\n};\n\nconst UNOP_MAP = {\n  '+': { alias: 'number' },\n  '-': { alias: 'negate' },\n  '~': { alias: 'bitwiseNot' },\n  '!': { alias: 'not' },\n};\n\nconst IgnoreWhitespace = (Rule) => Ignore(/^\\s+/, Rule);\nconst QuoteToken = Any(\n  /^('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')/,\n  /^(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")/,\n);\nconst NumericToken = Any(\n  /^((?:[0-9]+\\.?[0-9]*|\\.[0-9]+)(?:[eE][-+]?[0-9]+)?)\\b/,\n  /^(0[xX][0-9a-fA-F]+)\\b/,\n);\nconst NullToken = /^(null)\\b/;\nconst BooleanToken = /^(true|false)\\b/;\nconst IdentifierToken = /^([a-zA-Z_$][a-zA-Z0-9_$.]*(:[a-zA-Z_$]+)?)/;\nconst InterpolationChunkToken = /^((?:\\$(?!{)|\\\\.|[^`$\\\\])+)/;\nconst BinaryOperatorPrecedence = [\n  '**',\n  Any('*', '/', '%'),\n  Any('+', '-'),\n  Any('>>>', '<<', '>>'),\n  Any('<=', '>=', '<', '>'),\n  Any('===', '!==', '==', '!='),\n  /^&(?!&)/,\n  '^',\n  /^\\|(?!\\|)/,\n  '&&',\n  '||',\n  '??',\n  Any(':=', '+=', '-=', '*=', '/='),\n];\n\nconst INVALID_IDENT_REGEX = /^__proto__|prototype|constructor$/;\n\nexport function createExprContext({\n  funcs,\n  binops,\n  unops,\n  seed = 'expreval',\n  get,\n  set,\n  call,\n}: Partial<TExprContext> & { seed?: string }): TExprContext {\n  const vars: { [key: string]: TExprValue } = {};\n  return {\n    rng: seedrandom.default(seed),\n    funcs: { ...STDLIB, ...funcs },\n    binops: { ...BINOP_MAP, ...binops },\n    unops: { ...UNOP_MAP, ...unops },\n    get: async (scope, name) => {\n      if (name.match(INVALID_IDENT_REGEX)) {\n        return 0;\n      }\n      if (get) {\n        return get(scope, name) ?? null;\n      }\n      return vars[name] ?? null;\n    },\n    set: async (scope, name, value) => {\n      if (name.match(INVALID_IDENT_REGEX)) {\n        return;\n      }\n      if (set) {\n        return set(scope, name, value);\n      }\n      vars[name] = value;\n      return;\n    },\n    call,\n  };\n}\n\nexport type TExpressionCache = { [key: string]: TExpression };\n\nexport async function evaluateExpr(\n  code: string,\n  ctx: TExprContext = createExprContext({}),\n  scope: TScope = {},\n  cache: TExpressionCache = {},\n): Promise<TExprResult> {\n  return {\n    result: await executeAst(parseExpr(code, cache), ctx, scope),\n    ctx,\n  };\n}\n\nexport default evaluateExpr;\n\nexport function parseExpr(\n  code: string,\n  cache: TExpressionCache,\n  parser = DEFAULT_PARSER,\n): TExpression {\n  if (!cache[code]) {\n    cache[code] = parser(code.replace(/\\/\\/.*\\n/g, ''));\n  }\n  return cache[code]!;\n}\n\nexport function remapAst(\n  ast: TExpression,\n  res: (ast: TExpression) => TExpression,\n): TExpression {\n  switch (ast.type) {\n    case 'Literal':\n      return res(ast);\n    case 'Identifier':\n      return res(ast);\n    case 'CallExpression':\n      ast.arguments = ast.arguments.map((el) => remapAst(el, res));\n      return res(ast);\n    case 'BinaryExpression':\n      ast.left = remapAst(ast.left, res);\n      ast.right = remapAst(ast.right, res);\n      return res(ast);\n    case 'ConditionalExpression':\n      ast.test = remapAst(ast.test, res);\n      ast.consequent = remapAst(ast.consequent, res);\n      ast.alternate = remapAst(ast.alternate, res);\n      return res(ast);\n    case 'UnaryExpression':\n      ast.argument = remapAst(ast.argument, res);\n      return res(ast);\n    case 'TemplateLiteral':\n      ast.parts = ast.parts.map(([type, value]) => {\n        return type === 'expression'\n          ? [type, remapAst(value, res)]\n          : [type, value];\n      });\n      return res(ast);\n    case 'ComputedProperty':\n      ast.expression = remapAst(ast.expression, res);\n      return res(ast);\n    case 'ArrayLiteral':\n      ast.elements = ast.elements.map((el) => remapAst(el, res));\n      return res(ast);\n    case 'ObjectLiteral':\n      ast.properties = ast.properties.map(({ name, value }) => {\n        return {\n          name: remapAst(name, res),\n          value: value ? remapAst(value, res) : value,\n        };\n      });\n      return res(ast);\n    case 'ArrowFunction':\n      return res(ast);\n  }\n}\n\nexport function genCode(\n  ast: TExpression,\n  res: (ident: string) => string = (s) => s,\n): string {\n  switch (ast.type) {\n    case 'Literal':\n      return res(ast.raw);\n    case 'Identifier':\n      return res(ast.name);\n    case 'CallExpression':\n      return `${res(ast.callee.name)}(${ast.arguments\n        .map((el) => genCode(el, res))\n        .join(', ')})`;\n    case 'BinaryExpression':\n      return `${genCode(ast.left, res)} ${ast.operator} ${genCode(\n        ast.right,\n        res,\n      )}`;\n    case 'ConditionalExpression':\n      return `${genCode(ast.test, res)} ? ${genCode(\n        ast.consequent,\n        res,\n      )} : ${genCode(ast.alternate, res)}`;\n    case 'UnaryExpression':\n      return `${ast.operator}${genCode(ast.argument, res)}`;\n    case 'TemplateLiteral':\n      return (\n        '`' +\n        ast.parts\n          .map(([kind, value]) => {\n            if (kind === 'chunks') {\n              return value; // Hmm...\n            } else {\n              return '${' + genCode(value, res) + '}';\n            }\n          })\n          .join('') +\n        '`'\n      );\n    case 'ComputedProperty':\n      return '[' + genCode(ast.expression, res) + ']';\n    case 'ArrayLiteral':\n      return '[' + ast.elements.map((el) => genCode(el, res)).join(', ') + ']';\n    case 'ObjectLiteral':\n      return (\n        '{' +\n        ast.properties\n          .map((prop) => {\n            if (!prop.value) {\n              return `${genCode(prop.name, res)}`;\n            }\n            return `${genCode(prop.name, res)}: ${genCode(prop.value, res)}`;\n          })\n          .join(', ') +\n        '}'\n      );\n    case 'ArrowFunction':\n      return `(${ast.parameters.map((p) => p.name).join(', ')}) => ${genCode(\n        ast.result,\n        res,\n      )}`;\n  }\n}\n\nexport function rewriteCode(\n  code: string,\n  res: (ident: string) => string,\n  cache: TExpressionCache,\n) {\n  return genCode(parseExpr(code, cache), res);\n}\n\nasync function asyncMap<V, T>(\n  array: V[],\n  callback: (el: V, idx: number, arr: V[]) => Promise<T>\n) {\n  const out: T[] = []\n  for (let index = 0; index < array.length; index++) {\n    const m = await callback(array[index]!, index, array)\n    out.push(m)\n  }\n  return out\n}\n\nexport async function executeAst(\n  ast: TExpression,\n  ctx: TExprContext = createExprContext({}),\n  scope: TScope,\n): Promise<TExprValue> {\n  switch (ast.type) {\n    case 'Literal':\n      return ast.value;\n    case 'Identifier':\n      const value = await ctx.get(scope, ast.name);\n      return value !== undefined ? value : ast.name;\n    case 'CallExpression':\n      const fdef = Object.keys(ctx.funcs).includes(ast.callee.name)\n        ? ctx.funcs[ast.callee.name]\n        : null;\n      if (fdef && fdef.lazy) {\n        return await fdef.f(ctx, scope, ...ast.arguments);\n      }\n      const args: TExprValue[] = [];\n      if (fdef && fdef.assignment && ast.arguments.length > 1) {\n        const left = exprToIdentifier(ast.arguments[0]!) ?? '';\n        const right = ast.arguments.slice(1);\n        args.push(left, ...await asyncMap(right, async (expr) => await executeAst(expr, ctx, scope)));\n      } else {\n        args.push(...await asyncMap(ast.arguments, async (expr) => await executeAst(expr, ctx, scope)));\n      }\n      if (fdef) {\n        const result = fdef.f(ctx, scope, ...args);\n        return result;\n      }\n      if (ctx.call) {\n        return await ctx.call(ctx, scope, ast.callee.name, args);\n      }\n      throw new Error(`Function not found: '${ast.callee.name}'`);\n    case 'BinaryExpression':\n      const binop = Object.keys(ctx.binops).includes(ast.operator)\n        ? ctx.binops[ast.operator]\n        : null;\n      if (binop) {\n        return await executeAst(\n          {\n            type: 'CallExpression',\n            callee: {\n              name: binop.alias,\n              type: 'Identifier',\n            },\n            arguments: [ast.left, ast.right],\n          },\n          ctx,\n          scope,\n        );\n      }\n      throw new Error(`Operator not found: '${ast.operator}'`);\n    case 'ConditionalExpression':\n      const result = await executeAst(ast.test, ctx, scope);\n      if (toBoolean(result)) {\n        return executeAst(ast.consequent, ctx, scope);\n      }\n      return await executeAst(ast.alternate, ctx, scope);\n    case 'UnaryExpression':\n      const unop = Object.keys(ctx.unops).includes(ast.operator)\n        ? ctx.unops[ast.operator]\n        : null;\n      if (unop) {\n        return await executeAst(\n          {\n            type: 'CallExpression',\n            callee: {\n              name: unop.alias,\n              type: 'Identifier',\n            },\n            arguments: [ast.argument],\n          },\n          ctx,\n          scope,\n        );\n      }\n      throw new Error(`Operator not found: '${ast.operator}'`);\n    case 'TemplateLiteral':\n      let accum = '';\n      for (let i = 0; i < ast.parts.length; i++) {\n        const [kind, value] = ast.parts[i]!;\n        if (kind === 'chunks') {\n          accum += value;\n        } else if (kind === 'expression') {\n          accum += await executeAst(value, ctx, scope) + '';\n        }\n      }\n      return accum;\n    case 'ComputedProperty':\n      return await executeAst(ast.expression, ctx, scope);\n    case 'ArrayLiteral':\n      return await asyncMap(ast.elements, async (element) => await executeAst(element, ctx, scope));\n    case 'ObjectLiteral':\n      const obj = {};\n      for (let i = 0; i < ast.properties.length; i++) {\n        const { name, value } = ast.properties[i]!;\n        let key: string = '';\n        if (name.type === 'ComputedProperty') {\n          key = toString(await executeAst(name.expression, ctx, scope));\n        } else if (name.type === 'Identifier') {\n          key = name.name; // Don't evaluate this if 'bare'\n        } else if (name.type === 'Literal') {\n          key = name.value;\n        }\n        obj[key] = await executeAst(value ? value : name, ctx, scope);\n      }\n      return obj;\n    case 'ArrowFunction':\n      return {\n        params: ast.parameters.map(({ name }) => name),\n        body: ast.result,\n      } as any;\n    default:\n      console.info(ast);\n      throw new Error(`Syntax error`);\n  }\n}\n\nexport function exprToIdentifier(v: TExpression): string | null {\n  if (v.type === 'Identifier') {\n    return v.name;\n  }\n  return null;\n}\n\nexport function toNumber(v: any, fallback: number = 0): number {\n  if (typeof v === 'boolean') {\n    return v ? 1 : 0;\n  }\n  if (typeof v === 'number') {\n    return isNaN(v) ? fallback : v;\n  }\n  if (typeof v === 'string') {\n    if (v.includes('.')) {\n      return parseFloat(v);\n    }\n    return parseInt(v);\n  }\n  return fallback;\n}\n\nexport function toBoolean(v: TExprValue): boolean {\n  if (!v) {\n    return false;\n  }\n  if (typeof v === 'string' && v.match(/^\\s+$/)) {\n    return false;\n  }\n  if (v === 'false') {\n    return false;\n  }\n  if (v === '0') {\n    return false;\n  }\n  return true;\n}\n\nexport function toString(v: any): string {\n  if (typeof v === 'number') {\n    return v.toString(10);\n  }\n  if (v === true || v === 'true') {\n    return 'true';\n  }\n  if (!v) {\n    return '';\n  }\n  return v + '';\n}\n\nexport function toObject(v: any): TExprObject {\n  if (!v) {\n    return {};\n  }\n  if (v && typeof v === 'object') {\n    return v;\n  }\n  return {};\n}\n\nexport function toArray(v: any): TExprArray {\n  if (!v) {\n    return [];\n  }\n  if (Array.isArray(v)) {\n    return v.map((e) => toScalar(e));\n  }\n  if (v && typeof v === 'object') {\n    return Object.keys(v).map((k) => toScalar(v[k]));\n  }\n  if (\n    typeof v === 'number' ||\n    typeof v === 'string' ||\n    typeof v === 'boolean'\n  ) {\n    return [v];\n  }\n  return [];\n}\n\nexport function toScalar(n: any, radix: number = 10): TExprScalar {\n  if (typeof n === 'number') {\n    return n;\n  }\n  if (typeof n === 'string') {\n    return n;\n  }\n  if (typeof n === 'boolean') {\n    return n;\n  }\n  if (!n) {\n    return null;\n  }\n  if (typeof n === 'object') {\n    return '';\n  }\n  return n + '';\n}\n\nasync function setVar<T extends TExprValue>(\n  ctx: TExprContext,\n  scope: TScope,\n  name: any,\n  value: T,\n): Promise<T> {\n  const key = toString(name);\n  await ctx.set(scope, key, value);\n  return value;\n}\n\nasync function getVar(ctx: TExprContext, scope: TScope, name: any): Promise<TExprValue> {\n  return (await ctx.get(scope, name + '')) ?? null;\n}\n\nexport const STDLIB: DictOf<TExprFuncDef> = {\n  debug: {\n    async f(ctx, scope, ...args) {\n      console.debug(...args);\n      return null;\n    },\n  },\n  do: {\n    async f(ctx, scope, ...args) {\n      return args[args.length - 1] ?? null;\n    },\n  },\n  present: {\n    async f(ctx, scope, v) {\n      return !!v;\n    },\n  },\n  empty: {\n    async f(ctx, scope, v) {\n      if (Array.isArray(v)) {\n        return v.length < 1;\n      }\n      if (v && typeof v === 'object') {\n        return Object.keys(v).length < 1;\n      }\n      return !v;\n    },\n  },\n  blank: {\n    async f(ctx, scope, v) {\n      if (Array.isArray(v)) {\n        return v.length < 1;\n      }\n      if (v && typeof v === 'object') {\n        return Object.keys(v).length < 1;\n      }\n      if (typeof v === 'string' && (!v || v.match(/^\\s+$/))) {\n        return true;\n      }\n      return !v;\n    },\n  },\n  setVar: {\n    assignment: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(ctx, scope, left, right);\n    },\n  },\n  setAdd: {\n    assignment: true,\n    async f(ctx, scope, left, right) {\n      const lval = await getVar(ctx, scope, left);\n      if (typeof lval === 'string') {\n        return await setVar(ctx, scope, left, lval + right + '');\n      }\n      return await setVar(ctx, scope, left, toNumber(lval) + toNumber(right));\n    },\n  },\n  setSub: {\n    assignment: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(await getVar(ctx, scope, left)) - toNumber(right),\n      );\n    },\n  },\n  setMul: {\n    assignment: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(await getVar(ctx, scope, left)) * toNumber(right),\n      );\n    },\n  },\n  setDiv: {\n    assignment: true,\n    async f(ctx, scope, left, right) {\n      return await setVar(\n        ctx,\n        scope,\n        left,\n        toNumber(await getVar(ctx, scope, left)) / toNumber(right),\n      );\n    },\n  },\n  nullCoalesce: {\n    async f(ctx, scope, a, b) {\n      return a ?? b;\n    },\n  },\n  unixTimestampNow: {\n    async f() {\n      return Date.now();\n    },\n  },\n  unixTimestampForDate: {\n    async f(ctx, scope, year, mon, day, hour, min, second) {\n      return new Date(\n        toNumber(year),\n        toNumber(mon),\n        toNumber(day),\n        toNumber(hour),\n        toNumber(min),\n        toNumber(second),\n      ).getTime();\n    },\n  },\n  all: {\n    async f(ctx, scope, xs) {\n      if (!Array.isArray(xs)) {\n        return !!xs;\n      }\n      for (let i = 0; i < xs.length; i++) {\n        if (!xs[i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n  },\n  any: {\n    async f(ctx, scope, xs) {\n      if (!Array.isArray(xs)) {\n        return !!xs;\n      }\n      for (let i = 0; i < xs.length; i++) {\n        if (xs[i]) {\n          return true;\n        }\n      }\n      return false;\n    },\n  },\n  some: {\n    async f(ctx, scope, xs) {\n      return !!STDLIB['any']!.f(ctx, scope, xs as any);\n    },\n  },\n  none: {\n    async f(ctx, scope, xs) {\n      return !STDLIB['any']!.f(ctx, scope, xs as any);\n    },\n  },\n  or: {\n    async f(ctx, scope, a, b) {\n      return toBoolean(a) || toBoolean(b);\n    },\n  },\n  and: {\n    async f(ctx, scope, a, b) {\n      return toBoolean(a) && toBoolean(b);\n    },\n  },\n  not: {\n    async f(ctx, scope, a) {\n      return !toBoolean(a);\n    },\n  },\n  gt: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) > toNumber(b);\n    },\n  },\n  gte: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) >= toNumber(b);\n    },\n  },\n  lt: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) < toNumber(b);\n    },\n  },\n  lte: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) <= toNumber(b);\n    },\n  },\n  eq: {\n    async f(ctx, scope, a, b) {\n      return toString(a) === toString(b);\n    },\n  },\n  neq: {\n    async f(ctx, scope, a, b) {\n      return toString(a) !== toString(b);\n    },\n  },\n  rand: {\n    async f(ctx) {\n      return ctx.rng();\n    },\n  },\n  randInRange: {\n    async f(ctx, scope, min, max) {\n      return ctx.rng() * (Number(max) - Number(min)) + Number(min);\n    },\n  },\n  randInt: {\n    async f(ctx) {\n      return Math.floor(ctx.rng() * 10);\n    },\n  },\n  randIntInRange: {\n    async f(ctx, scope, min, max) {\n      min = Math.ceil(Number(min));\n      max = Math.floor(Number(max));\n      return Math.floor(ctx.rng() * (max - min + 1)) + min;\n    },\n  },\n  number: {\n    async f(ctx, scope, a) {\n      return Number(a);\n    },\n  },\n  isNumeric: {\n    async f(ctx, scope, a) {\n      if (typeof a === 'number') {\n        return true;\n      }\n      if (typeof a === 'string') {\n        return isNumeric(a);\n      }\n      return false;\n    },\n  },\n  bitwiseOr: {\n    async f(ctx, scope, a, b) {\n      return Number(a) | Number(b);\n    },\n  },\n  bitwiseXor: {\n    async f(ctx, scope, a, b) {\n      return Number(a) ^ Number(b);\n    },\n  },\n  bitwiseAnd: {\n    async f(ctx, scope, a, b) {\n      return Number(a) & Number(b);\n    },\n  },\n  bitwiseNot: {\n    async f(ctx, scope, a) {\n      return ~Number(a);\n    },\n  },\n  bitwiseLeftShift: {\n    async f(ctx, scope, a, b) {\n      return Number(a) << Number(b);\n    },\n  },\n  bitwiseRightShift: {\n    async f(ctx, scope, a, b) {\n      return Number(a) >> Number(b);\n    },\n  },\n  bitwiseRightshiftUnsigned: {\n    async f(ctx, scope, a, b) {\n      return Number(a) >>> Number(b);\n    },\n  },\n  negate: {\n    async f(ctx, scope, a) {\n      return -toNumber(a);\n    },\n  },\n  add: {\n    async f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a + b + '';\n      }\n      return toNumber(a) + toNumber(b);\n    },\n  },\n  sub: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) - toNumber(b);\n    },\n  },\n  div: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) / toNumber(b);\n    },\n  },\n  mul: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) * toNumber(b);\n    },\n  },\n  mod: {\n    async f(ctx, scope, a, b) {\n      return toNumber(a) % toNumber(b);\n    },\n  },\n  pow: {\n    async f(ctx, scope, a, b) {\n      return Math.pow(toNumber(a), toNumber(b));\n    },\n  },\n  abs: {\n    async f(ctx, scope, a) {\n      return Math.abs(toNumber(a));\n    },\n  },\n  acos: {\n    async f(ctx, scope, a) {\n      return Math.acos(toNumber(a));\n    },\n  },\n  acosh: {\n    async f(ctx, scope, a) {\n      return Math.acosh(toNumber(a));\n    },\n  },\n  asin: {\n    async f(ctx, scope, a) {\n      return Math.asin(toNumber(a));\n    },\n  },\n  asinh: {\n    async f(ctx, scope, a) {\n      return Math.asinh(toNumber(a));\n    },\n  },\n  atan: {\n    async f(ctx, scope, a) {\n      return Math.atan(toNumber(a));\n    },\n  },\n  atan2: {\n    async f(ctx, scope, a, b) {\n      return Math.atan2(toNumber(a), toNumber(b));\n    },\n  },\n  atanh: {\n    async f(ctx, scope, a) {\n      return Math.atanh(toNumber(a));\n    },\n  },\n  cbrt: {\n    async f(ctx, scope, a) {\n      return Math.cbrt(toNumber(a));\n    },\n  },\n  ceil: {\n    async f(ctx, scope, a) {\n      return Math.ceil(toNumber(a));\n    },\n  },\n  cos: {\n    async f(ctx, scope, a) {\n      return Math.cos(toNumber(a));\n    },\n  },\n  cosh: {\n    async f(ctx, scope, a) {\n      return Math.cosh(toNumber(a));\n    },\n  },\n  exp: {\n    async f(ctx, scope, a) {\n      return Math.exp(toNumber(a));\n    },\n  },\n  floor: {\n    async f(ctx, scope, a) {\n      return Math.floor(toNumber(a));\n    },\n  },\n  hypot: {\n    async f(ctx, scope, a) {\n      return Math.hypot(toNumber(a));\n    },\n  },\n  log: {\n    async f(ctx, scope, a) {\n      return Math.log(toNumber(a));\n    },\n  },\n  log10: {\n    async f(ctx, scope, a) {\n      return Math.log10(toNumber(a));\n    },\n  },\n  log2: {\n    async f(ctx, scope, a) {\n      return Math.log2(toNumber(a));\n    },\n  },\n  max: {\n    async f(ctx, scope, a) {\n      return Math.max(toNumber(a));\n    },\n  },\n  min: {\n    async f(ctx, scope, a) {\n      return Math.min(toNumber(a));\n    },\n  },\n  round: {\n    async f(ctx, scope, a) {\n      return Math.round(toNumber(a));\n    },\n  },\n  sign: {\n    async f(ctx, scope, a) {\n      return Math.sign(toNumber(a));\n    },\n  },\n  sin: {\n    async f(ctx, scope, a) {\n      return Math.sin(toNumber(a));\n    },\n  },\n  sinh: {\n    async f(ctx, scope, a) {\n      return Math.sinh(toNumber(a));\n    },\n  },\n  sqrt: {\n    async f(ctx, scope, a) {\n      return Math.sqrt(toNumber(a));\n    },\n  },\n  tan: {\n    async f(ctx, scope, a) {\n      return Math.tan(toNumber(a));\n    },\n  },\n  tanh: {\n    async f(ctx, scope, a) {\n      return Math.tanh(toNumber(a));\n    },\n  },\n  trunc: {\n    async f(ctx, scope, a) {\n      return Math.trunc(toNumber(a));\n    },\n  },\n  fromCharCode: {\n    async f(ctx, scope, a) {\n      return String.fromCharCode(Number(a));\n    },\n  },\n  fromCodePoint: {\n    async f(ctx, scope, a) {\n      return String.fromCodePoint(Number(a));\n    },\n  },\n  parseInt: {\n    async f(ctx, scope, a, b) {\n      return parseInt(toString(a), Number(b));\n    },\n  },\n  parseFloat: {\n    async f(ctx, scope, a) {\n      return parseFloat(toString(a));\n    },\n  },\n  charAt: {\n    async f(ctx, scope, a, b) {\n      return toString(a).charAt(Number(b));\n    },\n  },\n  charCodeAt: {\n    async f(ctx, scope, a, b) {\n      return toString(a).charCodeAt(Number(b));\n    },\n  },\n  codePointAt: {\n    async f(ctx, scope, a, b) {\n      return toString(a).codePointAt(Number(b)) ?? 0;\n    },\n  },\n  localeCompare: {\n    async f(ctx, scope, a, b) {\n      return toString(a).localeCompare(toString(b));\n    },\n  },\n  match: {\n    async f(ctx, scope, a, b) {\n      return !!toString(a).match(toString(b));\n    },\n  },\n  matchAll: {\n    async f(ctx, scope, a, b) {\n      return !!toString(a).match(toString(b));\n    },\n  },\n  padEnd: {\n    async f(ctx, scope, a, b, c) {\n      return toString(a).padEnd(Number(b), toString(c ?? ''));\n    },\n  },\n  padStart: {\n    async f(ctx, scope, a, b, c) {\n      return toString(a).padStart(Number(b), toString(c ?? ''));\n    },\n  },\n  repeat: {\n    async f(ctx, scope, a, b) {\n      return toString(a).repeat(Number(b));\n    },\n  },\n  replace: {\n    async f(ctx, scope, a, b, c) {\n      return toString(a).replace(toString(b), toString(c));\n    },\n  },\n  replaceAll: {\n    async f(ctx, scope, a, b, c) {\n      return toString(a).replaceAll(toString(b), toString(c));\n    },\n  },\n  startsWith: {\n    async f(ctx, scope, a, b) {\n      return toString(a).startsWith(toString(b));\n    },\n  },\n  substring: {\n    async f(ctx, scope, a, b, c) {\n      return toString(a).substring(Number(b), Number(c));\n    },\n  },\n  toLowerCase: {\n    async f(ctx, scope, a) {\n      return toString(a).toLowerCase();\n    },\n  },\n  toUpperCase: {\n    async f(ctx, scope, a) {\n      return toString(a).toUpperCase();\n    },\n  },\n  trim: {\n    async f(ctx, scope, a) {\n      return toString(a).trim();\n    },\n  },\n  trimEnd: {\n    async f(ctx, scope, a) {\n      return toString(a).trimEnd();\n    },\n  },\n  trimStart: {\n    async f(ctx, scope, a) {\n      return toString(a).trimStart();\n    },\n  },\n  clamp: {\n    async f(ctx, a, min, max) {\n      return clamp(toNumber(a), toNumber(min), toNumber(max));\n    },\n  },\n  avg: {\n    async f(ctx, scope, nn) {\n      return avg(toArray(nn).map((n) => toNumber(n)));\n    },\n  },\n  sum: {\n    async f(ctx, scope, nn) {\n      return sum(toArray(nn).map((n) => toNumber(n)));\n    },\n  },\n  join: {\n    async f(ctx, scope, ss, spacer) {\n      return toArray(ss).join(toString(spacer));\n    },\n  },\n  split: {\n    async f(ctx, scope, s, spacer) {\n      return toString(s).split(toString(spacer));\n    },\n  },\n  first: {\n    async f(ctx, scope, arr) {\n      if (typeof arr === 'string') {\n        return arr[0] ?? null;\n      }\n      return toArray(arr)[0] ?? null;\n    },\n  },\n  last: {\n    async f(ctx, scope, arr) {\n      if (typeof arr === 'string') {\n        return arr[arr.length] ?? null;\n      }\n      arr = toArray(arr);\n      return arr[arr.length] ?? null;\n    },\n  },\n  length: {\n    async f(ctx, scope, arr) {\n      if (typeof arr === 'string') {\n        return arr.length;\n      }\n      return toArray(arr).length;\n    },\n  },\n  concat: {\n    async f(ctx, scope, aa, bb) {\n      if (typeof aa === 'string') {\n        return aa + toString(bb);\n      }\n      return [...toArray(aa), ...toArray(bb)];\n    },\n  },\n  endsWith: {\n    async f(ctx, scope, a, b, c = '') {\n      if (Array.isArray(a)) {\n        a = a.join(toString(c));\n      }\n      return toString(a).endsWith(toString(b));\n    },\n  },\n  includes: {\n    async f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a.includes(toString(b));\n      }\n      return toArray(a).includes(b);\n    },\n  },\n  lastIndexOf: {\n    async f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a.lastIndexOf(toString(b));\n      }\n      return toArray(a).lastIndexOf(b);\n    },\n  },\n  indexOf: {\n    async f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a.indexOf(toString(b));\n      }\n      return toArray(a).indexOf(b);\n    },\n  },\n  nth: {\n    async f(ctx, scope, a, b) {\n      if (typeof a === 'string') {\n        return a[toNumber(b)] ?? null;\n      }\n      return toArray(a)[toNumber(b)] ?? null;\n    },\n  },\n  reverse: {\n    async f(ctx, scope, a) {\n      if (typeof a === 'string') {\n        return a.split('').reverse().join('');\n      }\n      return toArray(a).reverse();\n    },\n  },\n  take: {\n    async f(ctx, scope, a, n) {\n      if (typeof a === 'string') {\n        return a.slice(0, toNumber(n));\n      }\n      return toArray(a).slice(0, toNumber(n));\n    },\n  },\n  head: {\n    async f(ctx, scope, arr) {\n      return toArray(arr).slice(0, -1);\n    },\n  },\n  tail: {\n    async f(ctx, scope, arr) {\n      return toArray(arr).slice(1);\n    },\n  },\n  slice: {\n    async f(ctx, scope, arr, a, b) {\n      if (typeof arr === 'string') {\n        return arr.slice(toNumber(a), toNumber(b));\n      }\n      return toArray(arr).slice(toNumber(a), toNumber(b));\n    },\n  },\n  randEl: {\n    async f(ctx, scope, arr) {\n      arr = toArray(arr);\n      const i = STDLIB['randIntInRange']!.f(\n        ctx,\n        scope,\n        0 as any,\n        (arr.length - 1) as any,\n      ) as number;\n      return arr[i] ?? null;\n    },\n  },\n  push: {\n    async f(ctx, scope, arr, value) {\n      if (Array.isArray(arr)) {\n        arr.push(value);\n        return arr.length;\n      }\n      return -1;\n    },\n  },\n  pop: {\n    async f(ctx, scope, arr) {\n      if (Array.isArray(arr)) {\n        return arr.pop() ?? null;\n      }\n      return null;\n    },\n  },\n  shift: {\n    async f(ctx, scope, arr) {\n      if (Array.isArray(arr)) {\n        return arr.shift() ?? null;\n      }\n      return null;\n    },\n  },\n  unshift: {\n    async f(ctx, scope, arr, value) {\n      if (Array.isArray(arr)) {\n        arr.unshift(value);\n        return arr.length;\n      }\n      return -1;\n    },\n  },\n  keysOf: {\n    async f(ctx, scope, obj) {\n      return Object.keys(toObject(obj));\n    },\n  },\n  valuesOf: {\n    async f(ctx, scope, obj) {\n      return Object.values(toObject(obj));\n    },\n  },\n  getProperty: {\n    async f(ctx, scope, obj, key) {\n      return toObject(obj)[toString(key)] ?? null;\n    },\n  },\n  setProperty: {\n    async f(ctx, scope, obj, key, value) {\n      if (obj && typeof obj === 'object') {\n        obj[toString(key)] = value;\n      }\n      return obj;\n    },\n  },\n  map: {\n    async f(ctx, scope, arr, mapper) {\n      arr = toArray(arr);\n      const func = asFunc(mapper);\n      if (!func) {\n        return arr;\n      }\n      const { params, body } = func;\n      return asyncMap(arr, async (el, idx, coll) => {\n        const subscope = {\n          ...scope,\n          [params[0] ?? '__element__']: el,\n          [params[1] ?? '__index__']: idx,\n          [params[2] ?? '__collection__']: coll,\n        };\n        return await executeAst(\n          body,\n          {\n            ...ctx,\n            async get(scope, key) {\n              if (scope[key] !== undefined) {\n                return scope[key] ?? null;\n              }\n              return await ctx.get(scope, key);\n            },\n          },\n          subscope,\n        );\n      });\n    },\n  },\n  filter: {\n    async f(ctx, scope, arr, mapper) {\n      arr = toArray(arr);\n      const func = asFunc(mapper);\n      if (!func) {\n        return arr;\n      }\n      const { params, body } = func;\n      const out: any[] = []\n      for (let idx = 0; idx < arr.length; idx++) {\n        const el = arr[idx]!\n        const subscope = {\n          ...scope,\n          [params[0] ?? '__element__']: el,\n          [params[1] ?? '__index__']: idx,\n          [params[2] ?? '__collection__']: arr,\n        };\n        const result = toBoolean(\n          await executeAst(\n            body,\n            {\n              ...ctx,\n              async get(scope, key) {\n                if (scope[key] !== undefined) {\n                  return scope[key] ?? null;\n                }\n                return await ctx.get(scope, key);\n              },\n            },\n            subscope,\n          ),\n        );\n        if (result) {\n          out.push(el)\n        }\n      }\n      return out\n    },\n  },\n};\n\nfunction asFunc(v: any): { body: TExpression; params: string[] } | undefined {\n  if (v && typeof v === 'object') {\n    const { params, body } = v as any;\n    if (\n      Array.isArray(params) &&\n      body &&\n      typeof body === 'object' &&\n      typeof body['type'] === 'string'\n    ) {\n      return { body, params };\n    }\n  }\n  return;\n}\n\n// The code below is derived from code at https://github.com/dmaevsky/rd-parse. License:\n// The MIT License (MIT)\n// Copyright 2013 - present Dmitry Maevsky\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst associativity = (binop) => (binop === '**' ? r2l : l2r);\n\nfunction locAt(text, newPos, { pos, line, column }) {\n  while (pos < newPos) {\n    const ch = text[pos++];\n    if (ch === '\\n') {\n      column = 1;\n      line++;\n    } else {\n      column++;\n    }\n  }\n  return { pos, line, column };\n}\n\nconst markSeen = ($) => {\n  if ($.pos > $.lastSeen.pos) {\n    Object.assign($.lastSeen, locAt($.text, $.pos, $.lastSeen));\n  }\n};\n\nfunction RegexToken(pattern) {\n  return ($) => {\n    markSeen($);\n    const match = pattern.exec($.text.substring($.pos));\n    if (!match) {\n      return $;\n    }\n    const $next = {\n      ...$,\n      pos: $.pos + match[0].length,\n    };\n    for (let i = 1; i < match.length; i++) {\n      $.stack[$next.sp++] = match[i];\n    }\n    return $next;\n  };\n}\n\nfunction StringToken(pattern) {\n  return ($) => {\n    markSeen($);\n    if ($.text.startsWith(pattern, $.pos)) {\n      return {\n        ...$,\n        pos: $.pos + pattern.length,\n      };\n    }\n    return $;\n  };\n}\n\nfunction Use(rule) {\n  if (typeof rule === 'function') {\n    return rule;\n  }\n  if (rule instanceof RegExp) {\n    return RegexToken(rule);\n  }\n  if (typeof rule === 'string') {\n    return StringToken(rule);\n  }\n  throw new Error('Invalid rule');\n}\n\nfunction Ignore(toIgnore, rule) {\n  rule = Use(rule);\n  if (toIgnore) {\n    toIgnore = Ignore(null, Plus(toIgnore));\n  }\n\n  return ($) => {\n    const $cur = toIgnore ? toIgnore($) : $;\n    $.ignore.push(toIgnore);\n    const $next = rule($cur);\n    $.ignore.pop();\n    return $next === $cur ? $ : toIgnore ? toIgnore($next) : $next;\n  };\n}\n\nconst skipIgnored = ($) => {\n  if (!$.ignore.length) {\n    return $;\n  }\n  const toIgnore = $.ignore[$.ignore.length - 1];\n  return toIgnore ? toIgnore($) : $;\n};\n\nfunction All(...rules) {\n  rules = rules.map(Use);\n  return ($) => {\n    let $cur = $;\n    for (let i = 0; i < rules.length; i++) {\n      const $before = i > 0 ? skipIgnored($cur) : $cur;\n      const $after = rules[i]($before);\n      if ($after === $before) {\n        return $;\n      }\n      if ($after.pos > $before.pos || $after.sp > $before.sp) {\n        $cur = $after;\n      }\n    }\n    return $cur;\n  };\n}\n\nfunction Any(...rules) {\n  rules = rules.map(Use);\n  return ($) => {\n    for (let i = 0; i < rules.length; i++) {\n      const $next = rules[i]($);\n      if ($next !== $) {\n        return $next;\n      }\n    }\n    return $;\n  };\n}\n\nfunction Plus(rule) {\n  rule = Use(rule);\n  return ($) => {\n    while (true) {\n      const $cur = skipIgnored($);\n      const $next = rule($cur);\n      if ($next === $cur) {\n        return $;\n      }\n      $ = $next;\n    }\n  };\n}\n\nfunction Optional(rule) {\n  rule = Use(rule);\n  return ($) => {\n    const $next = rule($);\n    if ($next !== $) {\n      return $next;\n    }\n    return { ...$ };\n  };\n}\n\nfunction Node(rule, reducer) {\n  rule = Use(rule);\n  return ($) => {\n    const $next = rule($);\n    if ($next === $) {\n      return $;\n    }\n    const node = reducer($.stack.slice($.sp, $next.sp), $, $next);\n    $next.sp = $.sp;\n    if (node !== null) {\n      $.stack[$next.sp++] = node;\n    }\n    return $next;\n  };\n}\n\nconst Star = (rule) => Optional(Plus(rule));\n\nconst Y = (proc) => ((x) => proc((y) => x(x)(y)))((x) => proc((y) => x(x)(y)));\n\nconst START = (text, pos = 0) => ({\n  text,\n  ignore: [],\n  stack: [],\n  sp: 0,\n  lastSeen: locAt(text, pos, { pos: 0, line: 1, column: 1 }),\n  pos,\n});\n\nfunction Parser(\n  Grammar,\n  pos = 0,\n  partial = false,\n): (text: string) => TExpression {\n  return (text) => {\n    if (typeof text !== 'string') {\n      throw new Error('Parsing function expects a string input');\n    }\n    const $ = START(text, pos);\n    const $next = Grammar($);\n    if ($ === $next || (!partial && $next.pos < text.length)) {\n      throw new Error(\n        `Unexpected token at ${$.lastSeen.line}:${\n          $.lastSeen.column\n        }. Remainder: ${text.slice($.lastSeen.pos)}`,\n      );\n    }\n    return $.stack[0] as unknown as TExpression;\n  };\n}\n\nfunction l2r(parts, $) {\n  let left = parts[0];\n  for (let i = 1; i < parts.length; i += 2) {\n    const [operator, right] = [parts[i].operator, parts[i + 1]];\n    left = srcMap(\n      {\n        type: 'BinaryExpression',\n        left,\n        operator,\n        right,\n      },\n      $,\n      { pos: right.pos + right.text.length },\n    );\n  }\n  return left;\n}\n\nfunction r2l(parts, _, $next) {\n  let right = parts[parts.length - 1];\n  for (let i = parts.length - 2; i >= 0; i -= 2) {\n    const [left, operator] = [parts[i - 1], parts[i].operator];\n    right = srcMap(\n      {\n        type: 'BinaryExpression',\n        left,\n        operator,\n        right,\n      },\n      { pos: left.pos },\n      $next,\n    );\n  }\n  return right;\n}\n\nconst Operator = (Rule) =>\n  Node(Rule, (_, $, $next) => ({\n    $,\n    operator: $.text.substring($.pos, $next.pos),\n  }));\n\nconst srcMap = (obj, $, $next) =>\n  Object.defineProperties(obj, {\n    pos: { writable: true, configurable: true, value: $.pos },\n    text: {\n      writable: true,\n      configurable: true,\n      value: ($.text || $next.text).slice($.pos, $next.pos),\n    },\n  });\n\nconst DefaultGrammar = IgnoreWhitespace(\n  Y((Expression) => {\n    const Identifier = Node(IdentifierToken, ([name, ...rest]) => {\n      return {\n        type: 'Identifier',\n        name,\n      }\n    });\n    const StringLiteral = Node(QuoteToken, ([raw]) => ({\n      type: 'Literal',\n      value: raw.slice(1, -1),\n      raw,\n    }));\n    const NumericLiteral = Node(NumericToken, ([raw]) => ({\n      type: 'Literal',\n      value: +raw,\n      raw,\n    }));\n    const NullLiteral = Node(NullToken, ([raw]) => ({\n      type: 'Literal',\n      value: null,\n      raw,\n    }));\n    const BooleanLiteral = Node(BooleanToken, ([raw]) => ({\n      type: 'Literal',\n      value: raw === 'true',\n      raw,\n    }));\n    const InterpolationChunk = Node(InterpolationChunkToken, ([raw]) => [\n      'chunks',\n      raw,\n    ]);\n    const TemplateInlineExpression = Node(\n      All('${', IgnoreWhitespace(Expression), '}'),\n      ([expression]) => ['expression', expression],\n    );\n    const TemplateLiteral = Node(\n      Ignore(\n        null,\n        All('`', Star(Any(InterpolationChunk, TemplateInlineExpression)), '`'),\n      ),\n      (parts) => ({ type: 'TemplateLiteral', parts }),\n    );\n    const Literal = Any(\n      StringLiteral,\n      NumericLiteral,\n      NullLiteral,\n      BooleanLiteral,\n      TemplateLiteral,\n    );\n    const ArgumentsList = All(Expression, Star(All(',', Expression)));\n    const Arguments = Node(\n      All('(', Optional(All(ArgumentsList, Optional(','))), ')'),\n      (args) => ({\n        args,\n      }),\n    );\n    const ArgumentsExpression = Node(Any(Arguments), ([part], _, $next) => ({\n      part,\n      $next,\n    }));\n    const CompoundExpression = Node(\n      All(Expression, Star(All(',', Expression))),\n      (leafs) =>\n        leafs.length > 1 ? { type: 'CompoundExpression', leafs } : leafs[0],\n    );\n    const ComputedPropertyName = Node(\n      All('[', CompoundExpression, ']'),\n      ([expression]) => ({ type: 'ComputedProperty', expression }),\n    );\n    const PropertyName = Any(\n      Identifier,\n      StringLiteral,\n      NumericLiteral,\n      ComputedPropertyName,\n    );\n    const ShortNotation = Node(Identifier, ([expr], $, $next) =>\n      srcMap({ ...expr, shortNotation: true }, $, $next),\n    );\n    const PropertyDefinition = Node(\n      Any(All(PropertyName, ':', Expression), ShortNotation),\n      ([name, value]) => ({\n        name,\n        value,\n      }),\n    );\n    const PropertyDefinitions = All(\n      PropertyDefinition,\n      Star(All(',', PropertyDefinition)),\n    );\n    const PropertyDefinitionList = Optional(\n      All(PropertyDefinitions, Optional(',')),\n    );\n    const ObjectLiteral = Node(\n      All('{', PropertyDefinitionList, '}'),\n      (properties) => ({ type: 'ObjectLiteral', properties }),\n    );\n    const Element = Any(Expression);\n    const ElementList = All(Element, Star(All(',', Element)));\n    const ArrayLiteral = Node(\n      All('[', Optional(ElementList), ']'),\n      (elements) => ({\n        type: 'ArrayLiteral',\n        elements,\n      }),\n    );\n    const PrimaryExpression = Node(\n      Any(\n        Literal,\n        Identifier,\n        ArrayLiteral,\n        ObjectLiteral,\n        All('(', CompoundExpression, ')'),\n      ),\n      ([expr], $, $next) => srcMap(expr, $, $next),\n    );\n    const CallExpression = Node(\n      All(PrimaryExpression, Star(ArgumentsExpression)),\n      (parts, $, $last) => {\n        return parts.reduce((acc, { part, $next }) => {\n          return srcMap(\n            { type: 'CallExpression', callee: acc, arguments: part.args },\n            $,\n            $next,\n          );\n        });\n      },\n    );\n    const UnaryOperator = Operator(Any('+', '-', '~', '!'));\n    const UnaryExpression = Node(\n      All(Star(UnaryOperator), CallExpression),\n      (parts, _, $next) =>\n        parts.reduceRight((argument, { $, operator }) =>\n          srcMap({ type: 'UnaryExpression', argument, operator }, $, $next),\n        ),\n    );\n    const LogicalExpressionOrExpression = BinaryOperatorPrecedence.reduce(\n      (Expr, BinaryOp) =>\n        Node(\n          All(Expr, Star(All(Operator(BinaryOp), Expr))),\n          associativity(BinaryOp),\n        ),\n      UnaryExpression,\n    );\n    const TernaryExpression = Node(\n      All(\n        LogicalExpressionOrExpression,\n        Optional(All('?', Expression, ':', Expression)),\n      ),\n      ([test, consequent, alternate]) => {\n        return consequent\n          ? { type: 'ConditionalExpression', test, consequent, alternate }\n          : test;\n      },\n    );\n    const BoundName = Node(IdentifierToken, ([name], $, $next) =>\n      srcMap({ type: 'BoundName', name }, $, $next),\n    );\n    const FormalsList = Node(\n      All(BoundName, Star(All(',', BoundName))),\n      (bound) => bound,\n    );\n    const FormalParameters = Node(All('(', All(FormalsList), ')'), (parts) =>\n      parts.reduce((acc, part) => Object.assign(acc, part), []),\n    );\n    const ArrowParameters = Node(\n      Any(BoundName, FormalParameters),\n      ([params]) => params,\n    );\n    const FoolSafe = Node('{', () => {\n      throw new Error(\n        'Object literal returned from the arrow function needs to be enclosed in ()',\n      );\n    });\n    const ArrowResult = Any(FoolSafe, Expression);\n    const ArrowFunction = Node(\n      All(ArrowParameters, '=>', ArrowResult),\n      ([parameters, result]) => ({ type: 'ArrowFunction', parameters, result }),\n    );\n\n    return Node(Any(ArrowFunction, TernaryExpression), ([expr], $, $next) =>\n      srcMap(expr, $, $next),\n    );\n  }),\n);\n\nexport const DEFAULT_PARSER = Parser(DefaultGrammar);\n\nexport function clamp(n: number, min: number = 0, max: number = 1): number {\n  if (n < min) return min;\n  if (n > max) return max;\n  return n;\n}\nexport function avg(nn: number[]): number {\n  if (nn.length < 1) return 0;\n  return sum(nn) / nn.length;\n}\nexport function sum(nn: number[]): number {\n  let n = 0;\n  for (let i = 0; i < nn.length; i++) n += nn[i]!;\n  return n;\n}\n\nexport function isNumeric(a: any): boolean {\n  return !isNaN(parseFloat(a)) && isFinite(a);\n}\n"],"names":["ZExprScalar","z","union","number","string","boolean","null","CONSTS","E","Math","LN10","LN2","LOG10E","LOG2E","PI","SQRT1_2","SQRT2","BINOP_MAP","alias","UNOP_MAP","IgnoreWhitespace","Rule","Ignore","QuoteToken","Any","NumericToken","NullToken","BooleanToken","IdentifierToken","InterpolationChunkToken","BinaryOperatorPrecedence","INVALID_IDENT_REGEX","createExprContext","_a","_this","this","funcs","binops","unops","_b","seed","get","set","call","vars","rng","seedrandom","default","__assign","STDLIB","scope","name","__awaiter","match","value","evaluateExpr","code","ctx","cache","executeAst","parseExpr","result","sent","parser","DEFAULT_PARSER","replace","genCode","ast","res","s","type","raw","concat","callee","arguments","map","el","join","left","operator","right","test","consequent","alternate","argument","parts","kind","expression","elements","properties","prop","parameters","p","asyncMap","array","callback","out","index","length","m","push","undefined","_r","fdef","Object","keys","includes","lazy","f","apply","__spreadArray","args","assignment","exprToIdentifier","slice","_d","_c","expr","__generator","_e","_f","_h","_g","_j","Error","binop","toBoolean","unop","accum","i","_k","value_1","_l","element","obj","_m","value_2","key","_o","toString","_p","_q","params","body","console","info","v","toNumber","fallback","isNaN","parseFloat","parseInt","toObject","toArray","Array","isArray","e","toScalar","k","n","radix","setVar","getVar","debug","_i","do","present","empty","blank","setAdd","lval","setSub","setMul","setDiv","nullCoalesce","a","b","unixTimestampNow","Date","now","unixTimestampForDate","year","mon","day","hour","min","second","getTime","all","xs","any","some","none","or","and","not","gt","gte","lt","lte","eq","neq","rand","randInRange","max","Number","randInt","floor","randIntInRange","ceil","isNumeric","bitwiseOr","bitwiseXor","bitwiseAnd","bitwiseNot","bitwiseLeftShift","bitwiseRightShift","bitwiseRightshiftUnsigned","negate","add","sub","div","mul","mod","pow","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","cos","cosh","exp","hypot","log","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc","fromCharCode","String","fromCodePoint","charAt","charCodeAt","codePointAt","localeCompare","matchAll","padEnd","c","padStart","repeat","replaceAll","startsWith","substring","toLowerCase","toUpperCase","trim","trimEnd","trimStart","clamp","avg","nn","sum","ss","spacer","split","first","arr","last","aa","bb","endsWith","lastIndexOf","indexOf","nth","reverse","take","head","tail","randEl","pop","shift","unshift","keysOf","valuesOf","values","getProperty","setProperty","mapper","func","asFunc","idx","coll","subscope","filter","locAt","text","newPos","pos","line","column","markSeen","$","lastSeen","assign","Use","rule","RegExp","pattern","exec","$next","stack","sp","StringToken","toIgnore","Plus","$cur","ignore","skipIgnored","All","rules","$before","$after","Optional","Node","reducer","node","Star","START","l2r","srcMap","r2l","_","proc","x","Grammar","partial","Operator","defineProperties","writable","configurable","DefaultGrammar","y","Expression","Identifier","StringLiteral","NumericLiteral","NullLiteral","BooleanLiteral","InterpolationChunk","TemplateInlineExpression","TemplateLiteral","Literal","ArgumentsList","Arguments","ArgumentsExpression","part","CompoundExpression","leafs","PropertyName","ShortNotation","shortNotation","PropertyDefinition","PropertyDefinitions","PropertyDefinitionList","ObjectLiteral","Element","ElementList","ArrayLiteral","PrimaryExpression","CallExpression","$last","reduce","acc","UnaryOperator","UnaryExpression","reduceRight","LogicalExpressionOrExpression","Expr","BinaryOp","TernaryExpression","BoundName","FormalsList","bound","FormalParameters","ArrowParameters","FoolSafe","ArrowFunction","isFinite","remapAst"],"mappings":"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"}